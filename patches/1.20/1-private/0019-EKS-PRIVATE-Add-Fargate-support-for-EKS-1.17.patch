From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Gyuho Lee <leegyuho@amazon.com>
Date: Thu, 2 Apr 2020 17:55:36 -0700
Subject: [PATCH] --EKS-PRIVATE-- Add Fargate support for EKS 1.17

// owner: @saranbalaji90
// alpha: TBD
//
// Enables kubelet to validate and restrict pods based on security contexts.
PodSecurityValidator featuregate.Feature = "PodSecurityValidator"

ref.
https://code.amazon.com/packages/EKSDataPlaneKubernetes/logs/heads/release-1.16.8-eks

Sri Saran Balaji Vellore Rajakumar
Adding fargate support to aws cloud provider
https://code.amazon.com/packages/EKSDataPlaneKubernetes/commits/cceb46f3b6a2228fabd0e3ca79bdc3b5caf43f76#

Sri Saran Balaji Vellore Rajakumar
Adding PodCPULimit check for fargate pods
https://code.amazon.com/packages/EKSDataPlaneKubernetes/commits/cb1e0f769e04b6d5ec389ff0bf92bdded5360cdb#

Sri Saran Balaji Vellore Rajakumar
Removing fargate node prefix from NodeName before invoking DescribeENI
https://code.amazon.com/packages/EKSDataPlaneKubernetes/commits/074acc3b1e409983f035abf024b3c876f5a567df#

Sri Saran Balaji Vellore Rajakumar
Support PrivateIP address in node name
https://code.amazon.com/packages/EKSDataPlaneKubernetes/commits/b0e0580a0225c5afa4a36ebec4e1ff8b631a09c7#

Signed-off-by: Jyoti Mahapatra<jyotima@amazon.com>
---
 cmd/kubelet/app/server.go                     |   4 +-
 pkg/features/kube_features.go                 |   7 +
 pkg/kubelet/apis/config/fuzzer/fuzzer.go      |   1 +
 pkg/kubelet/apis/config/helpers_test.go       |   1 +
 .../KubeletConfiguration/after/v1beta1.yaml   |   1 +
 .../roundtrip/default/v1beta1.yaml            |   1 +
 pkg/kubelet/apis/config/types.go              |   4 +-
 pkg/kubelet/apis/config/v1beta1/defaults.go   |   3 +
 .../config/v1beta1/zz_generated.conversion.go |   6 +
 pkg/kubelet/cm/BUILD                          |   2 +
 pkg/kubelet/cm/helpers_linux.go               |  12 +-
 pkg/kubelet/kubelet.go                        |   9 +-
 pkg/kubelet/kuberuntime/BUILD                 |   2 +
 .../kuberuntime_container_linux.go            |   3 +
 pkg/kubelet/lifecycle/BUILD                   |   2 +
 .../lifecycle/fargate_pod_admit_handler.go    |  45 +++
 .../lifecycle/fargate_pod_validator.go        | 271 +++++++++++++++
 pkg/kubelet/server/server.go                  |  51 ++-
 pkg/kubelet/server/server_test.go             |   1 +
 pkg/kubelet/util/util.go                      |  20 +-
 .../k8s.io/kubelet/config/v1beta1/types.go    |   8 +
 .../config/v1beta1/zz_generated.deepcopy.go   |   5 +
 .../k8s.io/legacy-cloud-providers/aws/aws.go  | 312 ++++++++++++++----
 .../legacy-cloud-providers/aws/aws_fakes.go   |  29 ++
 .../legacy-cloud-providers/aws/aws_routes.go  |   6 +-
 .../legacy-cloud-providers/aws/aws_test.go    |  62 +++-
 .../legacy-cloud-providers/aws/instances.go   |  14 +-
 27 files changed, 778 insertions(+), 104 deletions(-)
 create mode 100644 pkg/kubelet/lifecycle/fargate_pod_admit_handler.go
 create mode 100644 pkg/kubelet/lifecycle/fargate_pod_validator.go

diff --git a/cmd/kubelet/app/server.go b/cmd/kubelet/app/server.go
index ff7e05feec1..5ec86c1d4de 100644
--- a/cmd/kubelet/app/server.go
+++ b/cmd/kubelet/app/server.go
@@ -1184,9 +1184,7 @@ func startKubelet(k kubelet.Bootstrap, podCfg *config.PodConfig, kubeCfg *kubele
 
 	// start the kubelet server
 	if enableServer {
-		go k.ListenAndServe(net.ParseIP(kubeCfg.Address), uint(kubeCfg.Port), kubeDeps.TLSOptions, kubeDeps.Auth,
-			enableCAdvisorJSONEndpoints, kubeCfg.EnableDebuggingHandlers, kubeCfg.EnableContentionProfiling, kubeCfg.EnableSystemLogHandler)
-
+		go k.ListenAndServe(net.ParseIP(kubeCfg.Address), uint(kubeCfg.Port), kubeDeps.TLSOptions, kubeDeps.Auth, enableCAdvisorJSONEndpoints, kubeCfg.EnableDebuggingHandlers, kubeCfg.EnableContentionProfiling, kubeCfg.EnableProfiling, kubeCfg.EnableSystemLogHandler)
 	}
 	if kubeCfg.ReadOnlyPort > 0 {
 		go k.ListenAndServeReadOnly(net.ParseIP(kubeCfg.Address), uint(kubeCfg.ReadOnlyPort), enableCAdvisorJSONEndpoints)
diff --git a/pkg/features/kube_features.go b/pkg/features/kube_features.go
index 35d261f29b6..c961a6dca52 100644
--- a/pkg/features/kube_features.go
+++ b/pkg/features/kube_features.go
@@ -472,6 +472,12 @@ const (
 	// Enables support for running container entrypoints as different usernames than their default ones.
 	WindowsRunAsUserName featuregate.Feature = "WindowsRunAsUserName"
 
+	// owner: @saranbalaji90
+	// alpha: TBD
+	//
+	// Enables kubelet to validate and restrict pods based on security contexts.
+	PodSecurityValidator featuregate.Feature = "PodSecurityValidator"
+
 	// owner: @adisky
 	// alpha: v1.14
 	// beta: v1.18
@@ -835,6 +841,7 @@ var defaultKubernetesFeatureGates = map[featuregate.Feature]featuregate.FeatureS
 	GracefulNodeShutdown:                           {Default: false, PreRelease: featuregate.Alpha},
 	ServiceLBNodePortControl:                       {Default: false, PreRelease: featuregate.Alpha},
 	MixedProtocolLBService:                         {Default: false, PreRelease: featuregate.Alpha},
+	PodSecurityValidator:                           {Default: false, PreRelease: featuregate.Alpha},
 
 	// inherited features from generic apiserver, relisted here to get a conflict if it is changed
 	// unintentionally on either side:
diff --git a/pkg/kubelet/apis/config/fuzzer/fuzzer.go b/pkg/kubelet/apis/config/fuzzer/fuzzer.go
index 104d8215526..3734c631dc6 100644
--- a/pkg/kubelet/apis/config/fuzzer/fuzzer.go
+++ b/pkg/kubelet/apis/config/fuzzer/fuzzer.go
@@ -104,6 +104,7 @@ func Funcs(codecs runtimeserializer.CodecFactory) []interface{} {
 			if obj.Logging.Format == "" {
 				obj.Logging.Format = "text"
 			}
+			obj.EnableProfiling = true
 			obj.EnableSystemLogHandler = true
 		},
 	}
diff --git a/pkg/kubelet/apis/config/helpers_test.go b/pkg/kubelet/apis/config/helpers_test.go
index aee4ba83ff5..376f0011d0d 100644
--- a/pkg/kubelet/apis/config/helpers_test.go
+++ b/pkg/kubelet/apis/config/helpers_test.go
@@ -168,6 +168,7 @@ var (
 		"EnableDebuggingHandlers",
 		"EnableServer",
 		"EnableSystemLogHandler",
+		"EnableProfiling",
 		"EnforceNodeAllocatable[*]",
 		"EventBurst",
 		"EventRecordQPS",
diff --git a/pkg/kubelet/apis/config/scheme/testdata/KubeletConfiguration/after/v1beta1.yaml b/pkg/kubelet/apis/config/scheme/testdata/KubeletConfiguration/after/v1beta1.yaml
index 364c43416ae..e725e50bb4b 100644
--- a/pkg/kubelet/apis/config/scheme/testdata/KubeletConfiguration/after/v1beta1.yaml
+++ b/pkg/kubelet/apis/config/scheme/testdata/KubeletConfiguration/after/v1beta1.yaml
@@ -24,6 +24,7 @@ cpuManagerPolicy: none
 cpuManagerReconcilePeriod: 10s
 enableControllerAttachDetach: true
 enableDebuggingHandlers: true
+enableProfiling: true
 enableServer: true
 enableSystemLogHandler: true
 enforceNodeAllocatable:
diff --git a/pkg/kubelet/apis/config/scheme/testdata/KubeletConfiguration/roundtrip/default/v1beta1.yaml b/pkg/kubelet/apis/config/scheme/testdata/KubeletConfiguration/roundtrip/default/v1beta1.yaml
index 364c43416ae..e725e50bb4b 100644
--- a/pkg/kubelet/apis/config/scheme/testdata/KubeletConfiguration/roundtrip/default/v1beta1.yaml
+++ b/pkg/kubelet/apis/config/scheme/testdata/KubeletConfiguration/roundtrip/default/v1beta1.yaml
@@ -24,6 +24,7 @@ cpuManagerPolicy: none
 cpuManagerReconcilePeriod: 10s
 enableControllerAttachDetach: true
 enableDebuggingHandlers: true
+enableProfiling: true
 enableServer: true
 enableSystemLogHandler: true
 enforceNodeAllocatable:
diff --git a/pkg/kubelet/apis/config/types.go b/pkg/kubelet/apis/config/types.go
index d518a6cf412..98480cbe723 100644
--- a/pkg/kubelet/apis/config/types.go
+++ b/pkg/kubelet/apis/config/types.go
@@ -373,7 +373,9 @@ type KubeletConfiguration struct {
 	// Logging specifies the options of logging.
 	// Refer [Logs Options](https://github.com/kubernetes/component-base/blob/master/logs/options.go) for more information.
 	Logging componentbaseconfig.LoggingConfiguration
-	// EnableSystemLogHandler enables /logs handler.
+	// EnableProfiling enables profiling on the kubelet.
+	EnableProfiling bool
+	// EnableSystemLogHandler enables system logs on the kubelet.
 	EnableSystemLogHandler bool
 	// ShutdownGracePeriod specifies the total duration that the node should delay the shutdown and total grace period for pod termination during a node shutdown.
 	// Defaults to 30 seconds, requires GracefulNodeShutdown feature gate to be enabled.
diff --git a/pkg/kubelet/apis/config/v1beta1/defaults.go b/pkg/kubelet/apis/config/v1beta1/defaults.go
index 3b46d4164b3..56223bd984c 100644
--- a/pkg/kubelet/apis/config/v1beta1/defaults.go
+++ b/pkg/kubelet/apis/config/v1beta1/defaults.go
@@ -242,4 +242,7 @@ func SetDefaults_KubeletConfiguration(obj *kubeletconfigv1beta1.KubeletConfigura
 	if obj.EnableSystemLogHandler == nil {
 		obj.EnableSystemLogHandler = utilpointer.BoolPtr(true)
 	}
+	if obj.EnableProfiling == nil {
+		obj.EnableProfiling = utilpointer.BoolPtr(true)
+	}
 }
diff --git a/pkg/kubelet/apis/config/v1beta1/zz_generated.conversion.go b/pkg/kubelet/apis/config/v1beta1/zz_generated.conversion.go
index 09aae527ecc..622c6cca776 100644
--- a/pkg/kubelet/apis/config/v1beta1/zz_generated.conversion.go
+++ b/pkg/kubelet/apis/config/v1beta1/zz_generated.conversion.go
@@ -347,6 +347,9 @@ func autoConvert_v1beta1_KubeletConfiguration_To_config_KubeletConfiguration(in
 	if err := v1alpha1.Convert_v1alpha1_LoggingConfiguration_To_config_LoggingConfiguration(&in.Logging, &out.Logging, s); err != nil {
 		return err
 	}
+	if err := v1.Convert_Pointer_bool_To_bool(&in.EnableProfiling, &out.EnableProfiling, s); err != nil {
+		return err
+	}
 	if err := v1.Convert_Pointer_bool_To_bool(&in.EnableSystemLogHandler, &out.EnableSystemLogHandler, s); err != nil {
 		return err
 	}
@@ -500,6 +503,9 @@ func autoConvert_config_KubeletConfiguration_To_v1beta1_KubeletConfiguration(in
 	if err := v1alpha1.Convert_config_LoggingConfiguration_To_v1alpha1_LoggingConfiguration(&in.Logging, &out.Logging, s); err != nil {
 		return err
 	}
+	if err := v1.Convert_bool_To_Pointer_bool(&in.EnableProfiling, &out.EnableProfiling, s); err != nil {
+		return err
+	}
 	if err := v1.Convert_bool_To_Pointer_bool(&in.EnableSystemLogHandler, &out.EnableSystemLogHandler, s); err != nil {
 		return err
 	}
diff --git a/pkg/kubelet/cm/BUILD b/pkg/kubelet/cm/BUILD
index 6935ba92d09..d8c66347254 100644
--- a/pkg/kubelet/cm/BUILD
+++ b/pkg/kubelet/cm/BUILD
@@ -63,6 +63,7 @@ go_library(
             "//pkg/kubelet/qos:go_default_library",
             "//pkg/kubelet/stats/pidlimit:go_default_library",
             "//pkg/kubelet/types:go_default_library",
+            "//pkg/kubelet/util:go_default_library",
             "//pkg/util/oom:go_default_library",
             "//pkg/util/procfs:go_default_library",
             "//pkg/util/sysctl:go_default_library",
@@ -124,6 +125,7 @@ go_library(
             "//pkg/kubelet/qos:go_default_library",
             "//pkg/kubelet/stats/pidlimit:go_default_library",
             "//pkg/kubelet/types:go_default_library",
+            "//pkg/kubelet/util:go_default_library",
             "//pkg/util/oom:go_default_library",
             "//pkg/util/procfs:go_default_library",
             "//pkg/util/sysctl:go_default_library",
diff --git a/pkg/kubelet/cm/helpers_linux.go b/pkg/kubelet/cm/helpers_linux.go
index 9b115ab5380..63014c8d1b2 100644
--- a/pkg/kubelet/cm/helpers_linux.go
+++ b/pkg/kubelet/cm/helpers_linux.go
@@ -34,7 +34,8 @@ import (
 	v1helper "k8s.io/kubernetes/pkg/apis/core/v1/helper"
 	v1qos "k8s.io/kubernetes/pkg/apis/core/v1/helper/qos"
 	kubefeatures "k8s.io/kubernetes/pkg/features"
-	"k8s.io/kubernetes/pkg/kubelet/cm/util"
+	cmutil "k8s.io/kubernetes/pkg/kubelet/cm/util"
+	util "k8s.io/kubernetes/pkg/kubelet/util"
 )
 
 const (
@@ -135,6 +136,7 @@ func ResourceConfigForPod(pod *v1.Pod, enforceCPULimits bool, cpuPeriod uint64)
 	// convert to CFS values
 	cpuShares := MilliCPUToShares(cpuRequests)
 	cpuQuota := MilliCPUToQuota(cpuLimits, int64(cpuPeriod))
+	cpuQuota = util.GetPodMaxCpuQuota(cpuQuota)
 
 	// track if limits were applied for each resource.
 	memoryLimitsDeclared := true
@@ -214,7 +216,7 @@ func getCgroupSubsystemsV1() (*CgroupSubsystems, error) {
 
 // getCgroupSubsystemsV2 returns information about the enabled cgroup v2 subsystems
 func getCgroupSubsystemsV2() (*CgroupSubsystems, error) {
-	content, err := ioutil.ReadFile(filepath.Join(util.CgroupRoot, "cgroup.controllers"))
+	content, err := ioutil.ReadFile(filepath.Join(cmutil.CgroupRoot, "cgroup.controllers"))
 	if err != nil {
 		return nil, err
 	}
@@ -223,10 +225,10 @@ func getCgroupSubsystemsV2() (*CgroupSubsystems, error) {
 	controllers := strings.Fields(string(content))
 	mountPoints := make(map[string]string, len(controllers))
 	for _, controller := range controllers {
-		mountPoints[controller] = util.CgroupRoot
+		mountPoints[controller] = cmutil.CgroupRoot
 		m := libcontainercgroups.Mount{
-			Mountpoint: util.CgroupRoot,
-			Root:       util.CgroupRoot,
+			Mountpoint: cmutil.CgroupRoot,
+			Root:       cmutil.CgroupRoot,
 			Subsystems: []string{controller},
 		}
 		mounts = append(mounts, m)
diff --git a/pkg/kubelet/kubelet.go b/pkg/kubelet/kubelet.go
index f32f51b90a1..ea489181940 100644
--- a/pkg/kubelet/kubelet.go
+++ b/pkg/kubelet/kubelet.go
@@ -192,7 +192,7 @@ type Bootstrap interface {
 	GetConfiguration() kubeletconfiginternal.KubeletConfiguration
 	BirthCry()
 	StartGarbageCollection()
-	ListenAndServe(address net.IP, port uint, tlsOptions *server.TLSOptions, auth server.AuthInterface, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableSystemLogHandler bool)
+	ListenAndServe(address net.IP, port uint, tlsOptions *server.TLSOptions, auth server.AuthInterface, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableProfiling, enableSystemLogHander bool)
 	ListenAndServeReadOnly(address net.IP, port uint, enableCAdvisorJSONEndpoints bool)
 	ListenAndServePodResources()
 	Run(<-chan kubetypes.PodUpdate)
@@ -797,6 +797,9 @@ func NewMainKubelet(kubeCfg *kubeletconfiginternal.KubeletConfiguration,
 		klet.appArmorValidator = apparmor.NewValidator(containerRuntime)
 		klet.softAdmitHandlers.AddPodAdmitHandler(lifecycle.NewAppArmorAdmitHandler(klet.appArmorValidator))
 	}
+	if utilfeature.DefaultFeatureGate.Enabled(features.PodSecurityValidator) {
+		klet.admitHandlers.AddPodAdmitHandler(lifecycle.NewFargatePodAdmitHandler())
+	}
 	klet.softAdmitHandlers.AddPodAdmitHandler(lifecycle.NewNoNewPrivsAdmitHandler(klet.containerRuntime))
 	klet.softAdmitHandlers.AddPodAdmitHandler(lifecycle.NewProcMountAdmitHandler(klet.containerRuntime))
 
@@ -2217,8 +2220,8 @@ func (kl *Kubelet) ResyncInterval() time.Duration {
 }
 
 // ListenAndServe runs the kubelet HTTP server.
-func (kl *Kubelet) ListenAndServe(address net.IP, port uint, tlsOptions *server.TLSOptions, auth server.AuthInterface, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableSystemLogHandler bool) {
-	server.ListenAndServeKubeletServer(kl, kl.resourceAnalyzer, address, port, tlsOptions, auth, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableSystemLogHandler)
+func (kl *Kubelet) ListenAndServe(address net.IP, port uint, tlsOptions *server.TLSOptions, auth server.AuthInterface, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableProfiling, enableSystemLogHandler bool) {
+	server.ListenAndServeKubeletServer(kl, kl.resourceAnalyzer, address, port, tlsOptions, auth, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableProfiling, enableSystemLogHandler)
 }
 
 // ListenAndServeReadOnly runs the kubelet HTTP server in read-only mode.
diff --git a/pkg/kubelet/kuberuntime/BUILD b/pkg/kubelet/kuberuntime/BUILD
index 6827346f5d1..55537c945aa 100644
--- a/pkg/kubelet/kuberuntime/BUILD
+++ b/pkg/kubelet/kuberuntime/BUILD
@@ -81,11 +81,13 @@ go_library(
             "//pkg/apis/core/v1/helper:go_default_library",
             "//pkg/kubelet/qos:go_default_library",
             "//vendor/github.com/opencontainers/runc/libcontainer/cgroups/fs:go_default_library",
+            "//pkg/kubelet/util:go_default_library",
         ],
         "@io_bazel_rules_go//go/platform:linux": [
             "//pkg/apis/core/v1/helper:go_default_library",
             "//pkg/kubelet/qos:go_default_library",
             "//vendor/github.com/opencontainers/runc/libcontainer/cgroups/fs:go_default_library",
+            "//pkg/kubelet/util:go_default_library",
         ],
         "@io_bazel_rules_go//go/platform:windows": [
             "//pkg/kubelet/apis:go_default_library",
diff --git a/pkg/kubelet/kuberuntime/kuberuntime_container_linux.go b/pkg/kubelet/kuberuntime/kuberuntime_container_linux.go
index 0f4fab34c04..226291635e1 100644
--- a/pkg/kubelet/kuberuntime/kuberuntime_container_linux.go
+++ b/pkg/kubelet/kuberuntime/kuberuntime_container_linux.go
@@ -30,6 +30,7 @@ import (
 	kubefeatures "k8s.io/kubernetes/pkg/features"
 	kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
 	"k8s.io/kubernetes/pkg/kubelet/qos"
+	"k8s.io/kubernetes/pkg/kubelet/util"
 )
 
 // applyPlatformSpecificContainerConfig applies platform specific configurations to runtimeapi.ContainerConfig.
@@ -83,6 +84,8 @@ func (m *kubeGenericRuntimeManager) generateLinuxContainerConfig(container *v1.C
 			cpuPeriod = int64(m.cpuCFSQuotaPeriod.Duration / time.Microsecond)
 		}
 		cpuQuota := milliCPUToQuota(cpuLimit.MilliValue(), cpuPeriod)
+		cpuQuota = util.GetPodMaxCpuQuota(cpuQuota)
+
 		lc.Resources.CpuQuota = cpuQuota
 		lc.Resources.CpuPeriod = cpuPeriod
 	}
diff --git a/pkg/kubelet/lifecycle/BUILD b/pkg/kubelet/lifecycle/BUILD
index d08f5ee1d94..a1e7640b3ab 100644
--- a/pkg/kubelet/lifecycle/BUILD
+++ b/pkg/kubelet/lifecycle/BUILD
@@ -11,6 +11,8 @@ go_library(
     srcs = [
         "admission_failure_handler_stub.go",
         "doc.go",
+        "fargate_pod_admit_handler.go",
+        "fargate_pod_validator.go",
         "handlers.go",
         "interfaces.go",
         "predicate.go",
diff --git a/pkg/kubelet/lifecycle/fargate_pod_admit_handler.go b/pkg/kubelet/lifecycle/fargate_pod_admit_handler.go
new file mode 100644
index 00000000000..b058b342349
--- /dev/null
+++ b/pkg/kubelet/lifecycle/fargate_pod_admit_handler.go
@@ -0,0 +1,45 @@
+package lifecycle
+
+import (
+	corev1 "k8s.io/api/core/v1"
+)
+
+var (
+	// unsupportedPodSpec is set on reason field for pods which cannot execute on this kubelet node
+	unsupportedPodSpecMessage = "UnsupportedPodSpec"
+)
+
+func NewFargatePodAdmitHandler() *fargatePodAdmitHandler {
+	return &fargatePodAdmitHandler{
+		podValidator: NewPodSpecValidator(),
+	}
+}
+
+// fargatePodAdmitHandler verifies security aspects of pod spec before admitting the pod.
+type fargatePodAdmitHandler struct {
+	podValidator PodValidator
+}
+
+// Admit checks security aspects of pod spec and decides whether pod spec is safe to run on this kubelet.
+// Currently fargatePodAdmitHandler runs fixed set of validation to verify if pod can run on fargate kubelet.
+func (f *fargatePodAdmitHandler) Admit(attrs *PodAdmitAttributes) PodAdmitResult {
+
+	admit, message := f.validate(attrs.Pod)
+
+	response := PodAdmitResult{
+		Admit: admit,
+	}
+	if !admit {
+		response.Message = message
+		response.Reason = unsupportedPodSpecMessage
+	}
+	return response
+}
+
+func (f *fargatePodAdmitHandler) validate(pod *corev1.Pod) (bool, string) {
+	err := f.podValidator.Validate(pod)
+	if err != nil {
+		return false, err.Error()
+	}
+	return true, ""
+}
diff --git a/pkg/kubelet/lifecycle/fargate_pod_validator.go b/pkg/kubelet/lifecycle/fargate_pod_validator.go
new file mode 100644
index 00000000000..aca39d8c6f5
--- /dev/null
+++ b/pkg/kubelet/lifecycle/fargate_pod_validator.go
@@ -0,0 +1,271 @@
+package lifecycle
+
+import (
+	"fmt"
+	"strings"
+
+	corev1 "k8s.io/api/core/v1"
+)
+
+const (
+	fargateSchedulerName = "fargate-scheduler"
+)
+
+// Linux capabilities permitted in container security contexts.
+// Copied from https://github.com/containerd/containerd/blob/257a7498d00827fbca08078f664cc6b4be27d7aa/oci/spec.go#L93
+var permittedCaps = map[string]bool{
+	"AUDIT_WRITE":      true,
+	"CHOWN":            true,
+	"DAC_OVERRIDE":     true,
+	"FOWNER":           true,
+	"FSETID":           true,
+	"KILL":             true,
+	"MKNOD":            true,
+	"NET_BIND_SERVICE": true,
+	"NET_RAW":          true,
+	"SETFCAP":          true,
+	"SETGID":           true,
+	"SETPCAP":          true,
+	"SETUID":           true,
+	"SYS_CHROOT":       true,
+}
+
+type validationFuncs func(*corev1.Pod) (bool, string)
+
+// PodValidator validates pods to be launched on Fargate.
+type PodValidator interface {
+	Validate(*corev1.Pod) error
+}
+
+type podSpecValidator struct{}
+
+// NewPodSpecValidator returns a PodValidator.
+func NewPodSpecValidator() PodValidator {
+	return &podSpecValidator{}
+}
+
+// Validate checks if the pod is eligible to run on Fargate.
+func (v *podSpecValidator) Validate(pod *corev1.Pod) error {
+	var messages []string
+
+	// Run through all validators to communicate all violations.
+	validators := []validationFuncs{
+		validateSchedulerName,
+		validateOwnerReferences,
+		validateTopLevelFields,
+		validateVolumes,
+		validateSecurityContexts,
+		validateVolumeDevices,
+		validatePorts,
+	}
+
+	for _, fn := range validators {
+		admit, message := fn(pod)
+		if !admit {
+			messages = append(messages, message)
+		}
+	}
+
+	// All validators must pass for the pod to be admitted.
+	var err error
+	if len(messages) != 0 {
+		err = fmt.Errorf("Pod not supported: %s", strings.Join(messages, ", "))
+	}
+
+	return err
+}
+
+func validateSchedulerName(pod *corev1.Pod) (bool, string) {
+	// Scheduler name must be Fargate.
+	if pod.Spec.SchedulerName != fargateSchedulerName {
+		return false, fmt.Sprintf("SchedulerName is not %s", fargateSchedulerName)
+	}
+	return true, ""
+}
+
+func validateOwnerReferences(pod *corev1.Pod) (bool, string) {
+	ownerReferences := pod.ObjectMeta.OwnerReferences
+	if len(ownerReferences) > 0 {
+		for _, reference := range ownerReferences {
+			if reference.Kind == "DaemonSet" {
+				return false, "DaemonSet not supported"
+			}
+		}
+	}
+	return true, ""
+}
+
+func validateSecurityContexts(pod *corev1.Pod) (bool, string) {
+	var invalidFields []string
+
+	for _, container := range pod.Spec.InitContainers {
+		admitted, message := validateContainerSecurityContext(container.SecurityContext)
+		if !admitted {
+			invalidFields = append(invalidFields, message)
+		}
+	}
+	for _, container := range pod.Spec.Containers {
+		admitted, message := validateContainerSecurityContext(container.SecurityContext)
+		if !admitted {
+			invalidFields = append(invalidFields, message)
+		}
+	}
+
+	admitted, message := validatePodSecurityContext(pod.Spec.SecurityContext)
+	if !admitted {
+		invalidFields = append(invalidFields, message)
+	}
+
+	if len(invalidFields) != 0 {
+		message := fmt.Sprintf("invalid SecurityContext fields: %s", strings.Join(invalidFields, ","))
+		return false, message
+	}
+	return true, ""
+}
+
+// placeholder method. All PodSecurityContext fields are safe for warmpool fargate
+// at launch, but we may need to add restrictions based on what is added here later
+func validatePodSecurityContext(sc *corev1.PodSecurityContext) (bool, string) {
+	return true, ""
+}
+
+// Allow ambient capabilities to be added. This is useful if only one or more are desired
+// while the rest are dropped. Ex:
+//
+//   securityContext:
+//     allowPrivilegeEscalation: false
+//     capabilities:
+//       add:
+//       - NET_BIND_SERVICE
+//       drop:
+//       - all
+func validateAddedCapabilities(requested []corev1.Capability) (permitted bool, rejectedCaps []string) {
+	for _, req := range requested {
+		if _, ok := permittedCaps[string(req)]; !ok {
+			rejectedCaps = append(rejectedCaps, string(req))
+		}
+	}
+	if len(rejectedCaps) != 0 {
+		return false, rejectedCaps
+	}
+	return true, nil
+}
+
+func validateContainerSecurityContext(sc *corev1.SecurityContext) (bool, string) {
+	var invalidFields []string
+
+	if sc == nil {
+		return true, ""
+	}
+
+	if sc.Capabilities != nil && len(sc.Capabilities.Add) != 0 {
+		admit, rejectedCaps := validateAddedCapabilities(sc.Capabilities.Add)
+		if !admit {
+			invalidFields = append(invalidFields, fmt.Sprintf("Capabilities added: %s", strings.Join(rejectedCaps, ", ")))
+		}
+	}
+
+	if sc.AllowPrivilegeEscalation != nil && *sc.AllowPrivilegeEscalation == true {
+		invalidFields = append(invalidFields, "AllowPrivilegeEscalation")
+	}
+
+	if sc.Privileged != nil && *sc.Privileged == true {
+		invalidFields = append(invalidFields, "Privileged")
+	}
+
+	if len(invalidFields) != 0 {
+		return false, strings.Join(invalidFields, ", ")
+	}
+	return true, ""
+}
+
+func validateTopLevelFields(pod *corev1.Pod) (bool, string) {
+	var invalidFields []string
+
+	if pod.Spec.HostNetwork == true {
+		invalidFields = append(invalidFields, "HostNetwork")
+	}
+	if pod.Spec.HostPID == true {
+		invalidFields = append(invalidFields, "HostPID")
+	}
+	if pod.Spec.HostIPC == true {
+		invalidFields = append(invalidFields, "HostIPC")
+	}
+
+	if len(invalidFields) != 0 {
+		message := fmt.Sprintf("fields not supported: %s", strings.Join(invalidFields, ", "))
+		return false, message
+	}
+	return true, ""
+}
+
+func validateVolumes(pod *corev1.Pod) (bool, string) {
+	var volumeNames []string
+
+	for _, volume := range pod.Spec.Volumes {
+		if volume.EmptyDir == nil &&
+			volume.Secret == nil &&
+			volume.ConfigMap == nil &&
+			volume.Projected == nil &&
+			volume.DownwardAPI == nil &&
+			volume.NFS == nil {
+			volumeNames = append(volumeNames, volume.Name)
+		}
+	}
+
+	if len(volumeNames) != 0 {
+		message := fmt.Sprintf("volumes not supported: %s", strings.Join(volumeNames, ","))
+		return false, message
+	}
+	return true, ""
+}
+
+func validateVolumeDevices(pod *corev1.Pod) (bool, string) {
+	var invalidContainers []string
+
+	for _, container := range pod.Spec.InitContainers {
+		if len(container.VolumeDevices) > 0 {
+			invalidContainers = append(invalidContainers, container.Name)
+		}
+	}
+	for _, container := range pod.Spec.Containers {
+		if len(container.VolumeDevices) > 0 {
+			invalidContainers = append(invalidContainers, container.Name)
+		}
+	}
+	if len(invalidContainers) > 0 {
+		return false, "volumeDevices not supported"
+	}
+	return true, ""
+}
+
+func validatePort(port corev1.ContainerPort) bool {
+	if port.HostPort > 0 {
+		return false
+	}
+	if port.HostIP != "" {
+		return false
+	}
+	return true
+}
+
+// TODO: return more specific port violation messages later.
+func validatePorts(pod *corev1.Pod) (bool, string) {
+	message := "port contains HostIP or HostPort"
+
+	for _, container := range pod.Spec.InitContainers {
+		for _, port := range container.Ports {
+			if !validatePort(port) {
+				return false, message
+			}
+		}
+	}
+	for _, container := range pod.Spec.Containers {
+		for _, port := range container.Ports {
+			if !validatePort(port) {
+				return false, message
+			}
+		}
+	}
+	return true, ""
+}
diff --git a/pkg/kubelet/server/server.go b/pkg/kubelet/server/server.go
index 237342421b5..cb7495b9439 100644
--- a/pkg/kubelet/server/server.go
+++ b/pkg/kubelet/server/server.go
@@ -144,9 +144,10 @@ func ListenAndServeKubeletServer(
 	enableCAdvisorJSONEndpoints,
 	enableDebuggingHandlers,
 	enableContentionProfiling,
+	enableProfiling,
 	enableSystemLogHandler bool) {
 	klog.Infof("Starting to listen on %s:%d", address, port)
-	handler := NewServer(host, resourceAnalyzer, auth, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableSystemLogHandler)
+	handler := NewServer(host, resourceAnalyzer, auth, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableProfiling, enableSystemLogHandler)
 	s := &http.Server{
 		Addr:           net.JoinHostPort(address.String(), strconv.FormatUint(uint64(port), 10)),
 		Handler:        &handler,
@@ -169,7 +170,7 @@ func ListenAndServeKubeletServer(
 // ListenAndServeKubeletReadOnlyServer initializes a server to respond to HTTP network requests on the Kubelet.
 func ListenAndServeKubeletReadOnlyServer(host HostInterface, resourceAnalyzer stats.ResourceAnalyzer, address net.IP, port uint, enableCAdvisorJSONEndpoints bool) {
 	klog.V(1).Infof("Starting to listen read-only on %s:%d", address, port)
-	s := NewServer(host, resourceAnalyzer, nil, enableCAdvisorJSONEndpoints, false, false, false)
+	s := NewServer(host, resourceAnalyzer, nil, enableCAdvisorJSONEndpoints, false, false, false, false)
 
 	server := &http.Server{
 		Addr:           net.JoinHostPort(address.String(), strconv.FormatUint(uint64(port), 10)),
@@ -227,6 +228,7 @@ func NewServer(
 	enableCAdvisorJSONEndpoints,
 	enableDebuggingHandlers,
 	enableContentionProfiling,
+	enableProfiling,
 	enableSystemLogHandler bool) Server {
 	server := Server{
 		host:                 host,
@@ -245,8 +247,11 @@ func NewServer(
 		// To maintain backward compatibility serve logs only when enableDebuggingHandlers is also enabled
 		// see https://github.com/kubernetes/kubernetes/pull/87273
 		server.InstallSystemLogHandler(enableSystemLogHandler)
-		if enableContentionProfiling {
-			goruntime.SetBlockProfileRate(1)
+		if enableProfiling {
+			server.InstallProfilingHandlers()
+			if enableContentionProfiling {
+				goruntime.SetBlockProfileRate(1)
+			}
 		}
 	} else {
 		server.InstallDebuggingDisabledHandlers()
@@ -481,8 +486,7 @@ func (s *Server) InstallDebuggingHandlers() {
 
 	s.addMetricsBucketMatcher("containerLogs")
 	ws = new(restful.WebService)
-	ws.
-		Path("/containerLogs")
+	ws.Path("/containerLogs")
 	ws.Route(ws.GET("/{podNamespace}/{podID}/{containerName}").
 		To(s.getContainerLogs).
 		Operation("getContainerLogs"))
@@ -491,6 +495,20 @@ func (s *Server) InstallDebuggingHandlers() {
 	s.addMetricsBucketMatcher("configz")
 	configz.InstallHandler(s.restfulCont)
 
+	// The /runningpods endpoint is used for testing only.
+	s.addMetricsBucketMatcher("runningpods")
+	ws = new(restful.WebService)
+	ws.
+		Path("/runningpods/").
+		Produces(restful.MIME_JSON)
+	ws.Route(ws.GET("").
+		To(s.getRunningPods).
+		Operation("getRunningPods"))
+	s.restfulCont.Add(ws)
+}
+
+// InstallProfilingHandlers registers the HTTP request patterns that provide profiling webservice
+func (s *Server) InstallProfilingHandlers() {
 	s.addMetricsBucketMatcher("debug")
 	handlePprofEndpoint := func(req *restful.Request, resp *restful.Response) {
 		name := strings.TrimPrefix(req.Request.URL.Path, pprofBasePath)
@@ -508,7 +526,7 @@ func (s *Server) InstallDebuggingHandlers() {
 		}
 	}
 	// Setup pprof handlers.
-	ws = new(restful.WebService).Path(pprofBasePath)
+	ws := new(restful.WebService).Path(pprofBasePath)
 	ws.Route(ws.GET("/{subpath:*}").To(func(req *restful.Request, resp *restful.Response) {
 		handlePprofEndpoint(req, resp)
 	})).Doc("pprof endpoint")
@@ -517,16 +535,19 @@ func (s *Server) InstallDebuggingHandlers() {
 	// Setup flags handlers.
 	// so far, only logging related endpoints are considered valid to add for these debug flags.
 	s.restfulCont.Handle("/debug/flags/v", routes.StringFlagPutHandler(logs.GlogSetter))
+}
 
-	// The /runningpods endpoint is used for testing only.
-	s.addMetricsBucketMatcher("runningpods")
-	ws = new(restful.WebService)
-	ws.
-		Path("/runningpods/").
-		Produces(restful.MIME_JSON)
+func (s *Server) InstallSystemLogHandlers() {
+	s.addMetricsBucketMatcher("logs")
+	ws := new(restful.WebService)
+	ws.Path(logsPath)
 	ws.Route(ws.GET("").
-		To(s.getRunningPods).
-		Operation("getRunningPods"))
+		To(s.getLogs).
+		Operation("getLogs"))
+	ws.Route(ws.GET("/{logpath:*}").
+		To(s.getLogs).
+		Operation("getLogs").
+		Param(ws.PathParameter("logpath", "path to the log").DataType("string")))
 	s.restfulCont.Add(ws)
 }
 
diff --git a/pkg/kubelet/server/server_test.go b/pkg/kubelet/server/server_test.go
index 263e9c9ac8a..37e74a29ba2 100644
--- a/pkg/kubelet/server/server_test.go
+++ b/pkg/kubelet/server/server_test.go
@@ -343,6 +343,7 @@ func newServerTestWithDebuggingHandlers(enableDebugging, enableSystemLogHandler
 		true,
 		enableDebugging,
 		false,
+		enableDebugging,
 		enableSystemLogHandler)
 	fw.serverUnderTest = &server
 	fw.testHTTPServer = httptest.NewServer(fw.serverUnderTest)
diff --git a/pkg/kubelet/util/util.go b/pkg/kubelet/util/util.go
index c2969a51126..1f5edaee902 100644
--- a/pkg/kubelet/util/util.go
+++ b/pkg/kubelet/util/util.go
@@ -18,8 +18,10 @@ package util
 
 import (
 	"fmt"
-
+	"k8s.io/apimachinery/pkg/api/resource"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/klog/v2"
+	"os"
 )
 
 // FromApiserverCache modifies <opts> so that the GET request will
@@ -43,3 +45,19 @@ func GetNodenameForKernel(hostname string, hostDomainName string, setHostnameAsF
 	}
 	return kernelHostname, nil
 }
+
+// GetPodMaxCpuQuota, returns the max CPU quota that can be allocated to pod.
+func GetPodMaxCpuQuota(currentCpuQuota int64) int64 {
+	fargatePodCPULimit := os.Getenv("FARGATE_POD_CPU_LIMIT")
+
+	if fargatePodCPULimit != "" {
+		fargatePodCPUResource := resource.MustParse(fargatePodCPULimit)
+		fargatePodCPUQuota := fargatePodCPUResource.MilliValue() * 100
+
+		if currentCpuQuota > fargatePodCPUQuota {
+			klog.Infof("updating cpuQuota for pod from %v to %v", currentCpuQuota, fargatePodCPUQuota)
+			return fargatePodCPUQuota
+		}
+	}
+	return currentCpuQuota
+}
diff --git a/staging/src/k8s.io/kubelet/config/v1beta1/types.go b/staging/src/k8s.io/kubelet/config/v1beta1/types.go
index 2c35b1f2403..8c143a4d2c5 100644
--- a/staging/src/k8s.io/kubelet/config/v1beta1/types.go
+++ b/staging/src/k8s.io/kubelet/config/v1beta1/types.go
@@ -811,7 +811,15 @@ type KubeletConfiguration struct {
 	//   Format: text
 	// + optional
 	Logging componentbaseconfigv1alpha1.LoggingConfiguration `json:"logging,omitempty"`
+	// enableProfiling enables profiling via web interface host:port/debug/pprof/
+	// Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
+	// enabling it may carry a performance impact.
+	// Default: true
+	// +optional
+	EnableProfiling *bool `json:"enableProfiling,omitempty"`
 	// enableSystemLogHandler enables system logs via web interface host:port/logs/
+	// Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
+	// enabling it may carry a performance impact.
 	// Default: true
 	// +optional
 	EnableSystemLogHandler *bool `json:"enableSystemLogHandler,omitempty"`
diff --git a/staging/src/k8s.io/kubelet/config/v1beta1/zz_generated.deepcopy.go b/staging/src/k8s.io/kubelet/config/v1beta1/zz_generated.deepcopy.go
index a6ad075c9ad..9adfbeda06d 100644
--- a/staging/src/k8s.io/kubelet/config/v1beta1/zz_generated.deepcopy.go
+++ b/staging/src/k8s.io/kubelet/config/v1beta1/zz_generated.deepcopy.go
@@ -296,6 +296,11 @@ func (in *KubeletConfiguration) DeepCopyInto(out *KubeletConfiguration) {
 		copy(*out, *in)
 	}
 	out.Logging = in.Logging
+	if in.EnableProfiling != nil {
+		in, out := &in.EnableProfiling, &out.EnableProfiling
+		*out = new(bool)
+		**out = **in
+	}
 	if in.EnableSystemLogHandler != nil {
 		in, out := &in.EnableSystemLogHandler, &out.EnableSystemLogHandler
 		*out = new(bool)
diff --git a/staging/src/k8s.io/legacy-cloud-providers/aws/aws.go b/staging/src/k8s.io/legacy-cloud-providers/aws/aws.go
index 172952369d5..ca6e3483315 100644
--- a/staging/src/k8s.io/legacy-cloud-providers/aws/aws.go
+++ b/staging/src/k8s.io/legacy-cloud-providers/aws/aws.go
@@ -250,6 +250,9 @@ const volumeAttachmentStuck = "VolumeAttachmentStuck"
 // Indicates that a node has volumes stuck in attaching state and hence it is not fit for scheduling more pods
 const nodeWithImpairedVolumes = "NodeWithImpairedVolumes"
 
+// privateDNSNamePrefix is the prefix added to ENI Private DNS Name.
+const privateDNSNamePrefix = "ip-"
+
 const (
 	// volumeAttachmentConsecutiveErrorLimit is the number of consecutive errors we will ignore when waiting for a volume to attach/detach
 	volumeAttachmentStatusConsecutiveErrorLimit = 10
@@ -282,6 +285,20 @@ const (
 	// Number of node names that can be added to a filter. The AWS limit is 200
 	// but we are using a lower limit on purpose
 	filterNodeLimit = 150
+
+	// fargateNodeNamePrefix string is added to awsInstance nodeName and providerID of Fargate nodes.
+	fargateNodeNamePrefix = "fargate-"
+)
+
+// computeType defines different compute types.
+type computeType string
+
+const (
+	// computeTypeFargate indicates its a Fargate node.
+	computeTypeFargate computeType = "FARGATE"
+
+	// computeTypeEC2 identifies its a EC2 node.
+	computeTypeEC2 computeType = "EC2"
 )
 
 const (
@@ -366,6 +383,8 @@ type EC2 interface {
 	ModifyInstanceAttribute(request *ec2.ModifyInstanceAttributeInput) (*ec2.ModifyInstanceAttributeOutput, error)
 
 	DescribeVpcs(input *ec2.DescribeVpcsInput) (*ec2.DescribeVpcsOutput, error)
+
+	DescribeNetworkInterfaces(input *ec2.DescribeNetworkInterfacesInput) (*ec2.DescribeNetworkInterfacesOutput, error)
 }
 
 // ELB is a simple pass-through of AWS' ELB client interface, which allows for testing
@@ -633,6 +652,18 @@ type CloudConfig struct {
 		//yourself in an non-AWS cloud and open an issue, please indicate that in the
 		//issue body.
 		DisableStrictZoneCheck bool
+
+		// Type of aws worker node. Indicates whether its FargateCompute/EC2/Other. Default is EC2
+		ComputeType computeType
+
+		// Private DNS name to be associated with Fargate node.
+		PrivateDNSName string
+
+		// IP Address to be associated with Fargate node.
+		IPAddress string
+
+		// Provider ID prefix to be used for Fargate node.
+		ProviderIDPrefix string
 	}
 	// [ServiceOverride "1"]
 	//  Service = s3
@@ -1207,6 +1238,15 @@ func (s *awsSdkEC2) DescribeVpcs(request *ec2.DescribeVpcsInput) (*ec2.DescribeV
 	return s.ec2.DescribeVpcs(request)
 }
 
+// DescribeNetworkInterfaces describes network interface provided in the input.
+func (s *awsSdkEC2) DescribeNetworkInterfaces(input *ec2.DescribeNetworkInterfacesInput) (*ec2.DescribeNetworkInterfacesOutput, error) {
+	requestTime := time.Now()
+	resp, err := s.ec2.DescribeNetworkInterfaces(input)
+	timeTaken := time.Since(requestTime).Seconds()
+	recordAWSMetric("describe_network_interfaces", timeTaken, err)
+	return resp, err
+}
+
 func init() {
 	registerMetrics()
 	cloudprovider.RegisterCloudProvider(ProviderName, func(config io.Reader) (cloudprovider.Interface, error) {
@@ -1291,10 +1331,14 @@ func newAWSCloud(cfg CloudConfig, awsServices Services) (*Cloud, error) {
 	if err != nil {
 		return nil, fmt.Errorf("error creating AWS metadata client: %q", err)
 	}
-	err = updateConfigZone(&cfg, metadata)
-	if err != nil {
-		return nil, fmt.Errorf("unable to determine AWS zone from cloud provider config or EC2 instance metadata: %v", err)
+
+	if cfg.Global.ComputeType != computeTypeFargate {
+		err = updateConfigZone(&cfg, metadata)
+		if err != nil {
+			return nil, fmt.Errorf("unable to determine AWS zone from cloud provider config or EC2 instance metadata: %v", err)
+		}
 	}
+
 	zone := cfg.Global.Zone
 	regionName, err := azToRegion(zone)
 	if err != nil {
@@ -1373,8 +1417,8 @@ func newAWSCloud(cfg CloudConfig, awsServices Services) (*Cloud, error) {
 		if err := awsCloud.tagging.init(cfg.Global.KubernetesClusterTag, cfg.Global.KubernetesClusterID); err != nil {
 			return nil, err
 		}
-	} else {
-		// TODO: Clean up double-API query
+	} else if cfg.Global.ComputeType != computeTypeFargate {
+		// TODO: Clean up double-API query and Update tags for Fargate node.
 		info, err := awsCloud.selfAWSInstance.describeInstance()
 		if err != nil {
 			return nil, err
@@ -1471,11 +1515,24 @@ func (c *Cloud) HasClusterID() bool {
 	return len(c.tagging.clusterID()) > 0
 }
 
+// getNodeAddressesForFargateNode generates list of Node addresses for Fargate node.
+func getNodeAddressesForFargateNode(privateDNSName, privateIP string) []v1.NodeAddress {
+	addresses := []v1.NodeAddress{}
+	addresses = append(addresses, v1.NodeAddress{Type: v1.NodeInternalIP, Address: privateIP})
+	if privateDNSName != "" {
+		addresses = append(addresses, v1.NodeAddress{Type: v1.NodeInternalDNS, Address: privateDNSName})
+	}
+	return addresses
+}
+
 // NodeAddresses is an implementation of Instances.NodeAddresses.
 func (c *Cloud) NodeAddresses(ctx context.Context, name types.NodeName) ([]v1.NodeAddress, error) {
 	if c.selfAWSInstance.nodeName == name || len(name) == 0 {
-		addresses := []v1.NodeAddress{}
+		if isFargateNode(string(name)) {
+			return getNodeAddressesForFargateNode(c.cfg.Global.PrivateDNSName, c.cfg.Global.IPAddress), nil
+		}
 
+		addresses := []v1.NodeAddress{}
 		macs, err := c.metadata.GetMetadata("network/interfaces/macs/")
 		if err != nil {
 			return nil, fmt.Errorf("error querying AWS metadata for %q: %q", "network/interfaces/macs", err)
@@ -1559,11 +1616,11 @@ func (c *Cloud) NodeAddresses(ctx context.Context, name types.NodeName) ([]v1.No
 		return addresses, nil
 	}
 
-	instance, err := c.getInstanceByNodeName(name)
+	instance, err := c.getAwsInstanceByNodeName(name)
 	if err != nil {
-		return nil, fmt.Errorf("getInstanceByNodeName failed for %q with %q", name, err)
+		return nil, fmt.Errorf("getAwsInstanceByNodeName failed for %q with %q", name, err)
 	}
-	return extractNodeAddresses(instance)
+	return instance.addresses, err
 }
 
 // parseMetadataLocalHostname parses the output of "local-hostname" metadata.
@@ -1647,6 +1704,14 @@ func (c *Cloud) NodeAddressesByProviderID(ctx context.Context, providerID string
 		return nil, err
 	}
 
+	if isFargateNode(string(instanceID)) {
+		eni, err := c.describeNetworkInterfaces(string(instanceID))
+		if eni == nil || err != nil {
+			return nil, err
+		}
+		return getNodeAddressesForFargateNode(aws.StringValue(eni.PrivateDnsName), aws.StringValue(eni.PrivateIpAddress)), nil
+	}
+
 	instance, err := describeInstance(c.ec2, instanceID)
 	if err != nil {
 		return nil, err
@@ -1663,6 +1728,11 @@ func (c *Cloud) InstanceExistsByProviderID(ctx context.Context, providerID strin
 		return false, err
 	}
 
+	if isFargateNode(string(instanceID)) {
+		eni, err := c.describeNetworkInterfaces(string(instanceID))
+		return eni != nil, err
+	}
+
 	request := &ec2.DescribeInstancesInput{
 		InstanceIds: []*string{instanceID.awsString()},
 	}
@@ -1698,6 +1768,11 @@ func (c *Cloud) InstanceShutdownByProviderID(ctx context.Context, providerID str
 		return false, err
 	}
 
+	if isFargateNode(string(instanceID)) {
+		eni, err := c.describeNetworkInterfaces(string(instanceID))
+		return eni != nil, err
+	}
+
 	request := &ec2.DescribeInstancesInput{
 		InstanceIds: []*string{instanceID.awsString()},
 	}
@@ -1734,15 +1809,15 @@ func (c *Cloud) InstanceID(ctx context.Context, nodeName types.NodeName) (string
 	if c.selfAWSInstance.nodeName == nodeName {
 		return "/" + c.selfAWSInstance.availabilityZone + "/" + c.selfAWSInstance.awsID, nil
 	}
-	inst, err := c.getInstanceByNodeName(nodeName)
+	inst, err := c.getAwsInstanceByNodeName(nodeName)
 	if err != nil {
 		if err == cloudprovider.InstanceNotFound {
 			// The Instances interface requires that we return InstanceNotFound (without wrapping)
 			return "", err
 		}
-		return "", fmt.Errorf("getInstanceByNodeName failed for %q with %q", nodeName, err)
+		return "", fmt.Errorf("getAWSInstanceByNodeName failed for %q with %q", nodeName, err)
 	}
-	return "/" + aws.StringValue(inst.Placement.AvailabilityZone) + "/" + aws.StringValue(inst.InstanceId), nil
+	return "/" + inst.availabilityZone + "/" + inst.awsID, nil
 }
 
 // InstanceTypeByProviderID returns the cloudprovider instance type of the node with the specified unique providerID
@@ -1754,6 +1829,10 @@ func (c *Cloud) InstanceTypeByProviderID(ctx context.Context, providerID string)
 		return "", err
 	}
 
+	if isFargateNode(string(instanceID)) {
+		return "", fmt.Errorf("instance type is not supported for Fargate")
+	}
+
 	instance, err := describeInstance(c.ec2, instanceID)
 	if err != nil {
 		return "", err
@@ -1767,11 +1846,11 @@ func (c *Cloud) InstanceType(ctx context.Context, nodeName types.NodeName) (stri
 	if c.selfAWSInstance.nodeName == nodeName {
 		return c.selfAWSInstance.instanceType, nil
 	}
-	inst, err := c.getInstanceByNodeName(nodeName)
+	inst, err := c.getAwsInstanceByNodeName(nodeName)
 	if err != nil {
-		return "", fmt.Errorf("getInstanceByNodeName failed for %q with %q", nodeName, err)
+		return "", fmt.Errorf("getAwsInstanceByNodeName failed for %q with %q", nodeName, err)
 	}
-	return aws.StringValue(inst.InstanceType), nil
+	return inst.instanceType, nil
 }
 
 // GetCandidateZonesForDynamicVolume retrieves  a list of all the zones in which nodes are running
@@ -1858,6 +1937,14 @@ func (c *Cloud) GetZoneByProviderID(ctx context.Context, providerID string) (clo
 	if err != nil {
 		return cloudprovider.Zone{}, err
 	}
+
+	if isFargateNode(string(instanceID)) {
+		return cloudprovider.Zone{
+			FailureDomain: c.cfg.Global.Zone,
+			Region:        c.region,
+		}, nil
+	}
+
 	instance, err := c.getInstanceByID(string(instanceID))
 	if err != nil {
 		return cloudprovider.Zone{}, err
@@ -1875,12 +1962,12 @@ func (c *Cloud) GetZoneByProviderID(ctx context.Context, providerID string) (clo
 // This is particularly useful in external cloud providers where the kubelet
 // does not initialize node data.
 func (c *Cloud) GetZoneByNodeName(ctx context.Context, nodeName types.NodeName) (cloudprovider.Zone, error) {
-	instance, err := c.getInstanceByNodeName(nodeName)
+	instance, err := c.getAwsInstanceByNodeName(nodeName)
 	if err != nil {
 		return cloudprovider.Zone{}, err
 	}
 	zone := cloudprovider.Zone{
-		FailureDomain: *(instance.Placement.AvailabilityZone),
+		FailureDomain: instance.availabilityZone,
 		Region:        c.region,
 	}
 
@@ -1926,25 +2013,37 @@ type awsInstance struct {
 
 	// instance type
 	instanceType string
+
+	// IP addresses associated with the node.
+	addresses []v1.NodeAddress
+
+	// BlockDeviceMapping for the node.
+	blockDeviceMappings []*ec2.InstanceBlockDeviceMapping
 }
 
-// newAWSInstance creates a new awsInstance object
-func newAWSInstance(ec2Service EC2, instance *ec2.Instance) *awsInstance {
+// buildAWSInstanceFromEC2 creates a new awsInstance object from EC2 instance.
+func buildAWSInstanceFromEC2(ec2Service EC2, instance *ec2.Instance) (*awsInstance, error) {
 	az := ""
 	if instance.Placement != nil {
 		az = aws.StringValue(instance.Placement.AvailabilityZone)
 	}
+	nodeAddresses, err := extractNodeAddresses(instance)
+	if err != nil {
+		return nil, err
+	}
 	self := &awsInstance{
-		ec2:              ec2Service,
-		awsID:            aws.StringValue(instance.InstanceId),
-		nodeName:         mapInstanceToNodeName(instance),
-		availabilityZone: az,
-		instanceType:     aws.StringValue(instance.InstanceType),
-		vpcID:            aws.StringValue(instance.VpcId),
-		subnetID:         aws.StringValue(instance.SubnetId),
+		ec2:                 ec2Service,
+		awsID:               aws.StringValue(instance.InstanceId),
+		nodeName:            mapInstanceToNodeName(instance),
+		availabilityZone:    az,
+		instanceType:        aws.StringValue(instance.InstanceType),
+		vpcID:               aws.StringValue(instance.VpcId),
+		subnetID:            aws.StringValue(instance.SubnetId),
+		addresses:           nodeAddresses,
+		blockDeviceMappings: instance.BlockDeviceMappings,
 	}
 
-	return self
+	return self, nil
 }
 
 // Gets the full information about this instance from the EC2 API
@@ -1957,13 +2056,12 @@ func (i *awsInstance) describeInstance() (*ec2.Instance, error) {
 // Otherwise the mountDevice is assigned by finding the first available mountDevice, and it is returned with alreadyAttached=false.
 func (c *Cloud) getMountDevice(
 	i *awsInstance,
-	info *ec2.Instance,
 	volumeID EBSVolumeID,
 	assign bool) (assigned mountDevice, alreadyAttached bool, err error) {
 
 	deviceMappings := map[mountDevice]EBSVolumeID{}
 	volumeStatus := map[EBSVolumeID]string{} // for better logging of volume status
-	for _, blockDevice := range info.BlockDeviceMappings {
+	for _, blockDevice := range i.blockDeviceMappings {
 		name := aws.StringValue(blockDevice.DeviceName)
 		name = strings.TrimPrefix(name, "/dev/sd")
 		name = strings.TrimPrefix(name, "/dev/xvd")
@@ -2334,12 +2432,17 @@ func (d *awsDisk) deleteVolume() (bool, error) {
 	return true, nil
 }
 
-// Builds the awsInstance for the EC2 instance on which we are running.
+// Builds the awsInstance for the aws compute on which we are running.
 // This is called when the AWSCloud is initialized, and should not be called otherwise (because the awsInstance for the local instance is a singleton with drive mapping state)
 func (c *Cloud) buildSelfAWSInstance() (*awsInstance, error) {
 	if c.selfAWSInstance != nil {
 		panic("do not call buildSelfAWSInstance directly")
 	}
+
+	if c.cfg.Global.ComputeType == computeTypeFargate {
+		return c.buildAWSInstanceForFargate()
+	}
+
 	instanceID, err := c.metadata.GetMetadata("instance-id")
 	if err != nil {
 		return nil, fmt.Errorf("error fetching instance-id from ec2 metadata service: %q", err)
@@ -2357,7 +2460,7 @@ func (c *Cloud) buildSelfAWSInstance() (*awsInstance, error) {
 	if err != nil {
 		return nil, fmt.Errorf("error finding instance %s: %q", instanceID, err)
 	}
-	return newAWSInstance(c.ec2, instance), nil
+	return buildAWSInstanceFromEC2(c.ec2, instance)
 }
 
 // wrapAttachError wraps the error returned by an AttachVolume request with
@@ -2389,7 +2492,7 @@ func (c *Cloud) AttachDisk(diskName KubernetesVolumeID, nodeName types.NodeName)
 		return "", err
 	}
 
-	awsInstance, info, err := c.getFullInstance(nodeName)
+	awsInstance, err := c.getFullInstance(nodeName)
 	if err != nil {
 		return "", fmt.Errorf("error finding instance %s: %q", nodeName, err)
 	}
@@ -2410,7 +2513,7 @@ func (c *Cloud) AttachDisk(diskName KubernetesVolumeID, nodeName types.NodeName)
 		}
 	}()
 
-	mountDevice, alreadyAttached, err = c.getMountDevice(awsInstance, info, disk.awsID, true)
+	mountDevice, alreadyAttached, err = c.getMountDevice(awsInstance, disk.awsID, true)
 	if err != nil {
 		return "", err
 	}
@@ -2501,9 +2604,12 @@ func (c *Cloud) DetachDisk(diskName KubernetesVolumeID, nodeName types.NodeName)
 		return "", nil
 	}
 
-	awsInstance := newAWSInstance(c.ec2, diskInfo.ec2Instance)
+	awsInstance, err := buildAWSInstanceFromEC2(c.ec2, diskInfo.ec2Instance)
+	if err != nil {
+		return "", err
+	}
 
-	mountDevice, alreadyAttached, err := c.getMountDevice(awsInstance, diskInfo.ec2Instance, diskInfo.disk.awsID, false)
+	mountDevice, alreadyAttached, err := c.getMountDevice(awsInstance, diskInfo.disk.awsID, false)
 	if err != nil {
 		return "", err
 	}
@@ -2841,7 +2947,7 @@ func (c *Cloud) DisksAreAttached(nodeDisks map[types.NodeName][]KubernetesVolume
 		for _, diskName := range diskNames {
 			setNodeDisk(attached, diskName, nodeName, false)
 		}
-		nodeNames = append(nodeNames, mapNodeNameToPrivateDNSName(nodeName))
+		nodeNames = append(nodeNames, string(nodeName))
 	}
 
 	// Note that we get instances regardless of state.
@@ -4926,12 +5032,6 @@ func (c *Cloud) describeInstances(filters []*ec2.Filter) ([]*ec2.Instance, error
 	return matches, nil
 }
 
-// mapNodeNameToPrivateDNSName maps a k8s NodeName to an AWS Instance PrivateDNSName
-// This is a simple string cast
-func mapNodeNameToPrivateDNSName(nodeName types.NodeName) string {
-	return string(nodeName)
-}
-
 // mapInstanceToNodeName maps a EC2 instance to a k8s NodeName, by extracting the PrivateDNSName
 func mapInstanceToNodeName(i *ec2.Instance) types.NodeName {
 	return types.NodeName(aws.StringValue(i.PrivateDnsName))
@@ -4945,12 +5045,15 @@ var aliveFilter = []string{
 	ec2.InstanceStateNameStopped,
 }
 
-// Returns the instance with the specified node name
+// Returns the aws instance with the specified node name
 // Returns nil if it does not exist
-func (c *Cloud) findInstanceByNodeName(nodeName types.NodeName) (*ec2.Instance, error) {
-	privateDNSName := mapNodeNameToPrivateDNSName(nodeName)
+func (c *Cloud) findAwsInstanceByNodeName(nodeName types.NodeName) (*awsInstance, error) {
+	nn := string(nodeName)
+	if isFargateNode(nn) {
+		return c.buildAWSInstanceForFargateNode(nn)
+	}
 	filters := []*ec2.Filter{
-		newEc2Filter("private-dns-name", privateDNSName),
+		newEc2Filter("private-dns-name", nn),
 		// exclude instances in "terminated" state
 		newEc2Filter("instance-state-name", aliveFilter...),
 	}
@@ -4966,13 +5069,13 @@ func (c *Cloud) findInstanceByNodeName(nodeName types.NodeName) (*ec2.Instance,
 	if len(instances) > 1 {
 		return nil, fmt.Errorf("multiple instances found for name: %s", nodeName)
 	}
-	return instances[0], nil
+	return buildAWSInstanceFromEC2(c.ec2, instances[0])
 }
 
 // Returns the instance with the specified node name
-// Like findInstanceByNodeName, but returns error if node not found
-func (c *Cloud) getInstanceByNodeName(nodeName types.NodeName) (*ec2.Instance, error) {
-	var instance *ec2.Instance
+// Like findAwsInstanceByNodeName, but returns error if node not found
+func (c *Cloud) getAwsInstanceByNodeName(nodeName types.NodeName) (*awsInstance, error) {
+	var instance *awsInstance
 
 	// we leverage node cache to try to retrieve node's provider id first, as
 	// get instance by provider id is way more efficient than by filters in
@@ -4980,9 +5083,14 @@ func (c *Cloud) getInstanceByNodeName(nodeName types.NodeName) (*ec2.Instance, e
 	awsID, err := c.nodeNameToProviderID(nodeName)
 	if err != nil {
 		klog.V(3).Infof("Unable to convert node name %q to aws instanceID, fall back to findInstanceByNodeName: %v", nodeName, err)
-		instance, err = c.findInstanceByNodeName(nodeName)
+		instance, err = c.findAwsInstanceByNodeName(nodeName)
 	} else {
-		instance, err = c.getInstanceByID(string(awsID))
+		var ec2Instance *ec2.Instance
+		ec2Instance, err = c.getInstanceByID(string(awsID))
+		if err != nil {
+			return nil, err
+		}
+		instance, err = buildAWSInstanceFromEC2(c.ec2, ec2Instance)
 	}
 	if err == nil && instance == nil {
 		return nil, cloudprovider.InstanceNotFound
@@ -4990,17 +5098,16 @@ func (c *Cloud) getInstanceByNodeName(nodeName types.NodeName) (*ec2.Instance, e
 	return instance, err
 }
 
-func (c *Cloud) getFullInstance(nodeName types.NodeName) (*awsInstance, *ec2.Instance, error) {
+func (c *Cloud) getFullInstance(nodeName types.NodeName) (*awsInstance, error) {
 	if nodeName == "" {
 		instance, err := c.getInstanceByID(c.selfAWSInstance.awsID)
-		return c.selfAWSInstance, instance, err
-	}
-	instance, err := c.getInstanceByNodeName(nodeName)
-	if err != nil {
-		return nil, nil, err
+		if err != nil {
+			return nil, err
+		}
+		return buildAWSInstanceFromEC2(c.ec2, instance)
 	}
-	awsInstance := newAWSInstance(c.ec2, instance)
-	return awsInstance, instance, err
+	instance, err := c.getAwsInstanceByNodeName(nodeName)
+	return instance, err
 }
 
 func (c *Cloud) nodeNameToProviderID(nodeName types.NodeName) (InstanceID, error) {
@@ -5090,3 +5197,88 @@ func constructStsEndpoint(arnString, region string) (string, error) {
 	}
 	return fmt.Sprintf("sts.%s.%s", region, suffix), nil
 }
+
+// isFargateNode returns true if given node runs on Fargate compute
+func isFargateNode(nodeName string) bool {
+	return strings.HasPrefix(nodeName, fargateNodeNamePrefix)
+}
+
+// buildAWSInstanceForFargate builds AWSInstance object from config file.
+// ProviderID will be <ProviderIDPrefix>/NodeName
+// NodeName will be fargate-PrivateDNSName
+func (c *Cloud) buildAWSInstanceForFargate() (*awsInstance, error) {
+	nodeName := buildNodeNameForFargate(c.cfg.Global.PrivateDNSName, c.cfg.Global.IPAddress)
+	return &awsInstance{
+		ec2:              c.ec2,
+		awsID:            buildProviderIDForFargateNode(c.cfg.Global.ProviderIDPrefix, nodeName),
+		nodeName:         types.NodeName(nodeName),
+		availabilityZone: c.cfg.Global.Zone,
+		vpcID:            c.cfg.Global.VPC,
+		subnetID:         c.cfg.Global.SubnetID,
+		addresses:        getNodeAddressesForFargateNode(c.cfg.Global.PrivateDNSName, c.cfg.Global.IPAddress),
+	}, nil
+}
+
+// buildNodeNameForFargate builds node name for Fargate.
+func buildNodeNameForFargate(privateDNSName, privateIP string) string {
+	if privateDNSName != "" {
+		return fmt.Sprintf("%s%s", fargateNodeNamePrefix, privateDNSName)
+	}
+	return fmt.Sprintf("%s%s", fargateNodeNamePrefix, privateIP)
+}
+
+// buildProviderIDForFargateNode builds providerID for Fargate.
+func buildProviderIDForFargateNode(providerIDPrefix, nodeName string) string {
+	return fmt.Sprintf("%s/%s", providerIDPrefix, nodeName)
+}
+
+// buildAWSInstanceForFargateNode builds awsInstance by describing network interface
+func (c *Cloud) buildAWSInstanceForFargateNode(nodeName string) (*awsInstance, error) {
+	networkInterface, err := c.describeNetworkInterfaces(nodeName)
+	if networkInterface == nil || err != nil {
+		return nil, err
+	}
+
+	return &awsInstance{
+		ec2:              c.ec2,
+		awsID:            buildProviderIDForFargateNode(c.cfg.Global.ProviderIDPrefix, nodeName),
+		nodeName:         types.NodeName(nodeName),
+		availabilityZone: aws.StringValue(networkInterface.AvailabilityZone),
+		vpcID:            aws.StringValue(networkInterface.VpcId),
+		subnetID:         aws.StringValue(networkInterface.SubnetId),
+		addresses:        getNodeAddressesForFargateNode(aws.StringValue(networkInterface.PrivateDnsName), aws.StringValue(networkInterface.PrivateIpAddress)),
+	}, nil
+}
+
+// describeNetworkInterfaces returns network interface information for the given DNS name.
+func (c *Cloud) describeNetworkInterfaces(nodeName string) (*ec2.NetworkInterface, error) {
+	eniIpOrDns := strings.TrimPrefix(nodeName, fargateNodeNamePrefix)
+
+	filters := []*ec2.Filter{
+		newEc2Filter("attachment.status", "attached"),
+		newEc2Filter("vpc-id", c.vpcID),
+	}
+
+	if strings.HasPrefix(eniIpOrDns, privateDNSNamePrefix) {
+		filters = append(filters, newEc2Filter("private-dns-name", eniIpOrDns))
+	} else {
+		filters = append(filters, newEc2Filter("private-ip-address", eniIpOrDns))
+	}
+
+	request := &ec2.DescribeNetworkInterfacesInput{
+		Filters: filters,
+	}
+
+	eni, err := c.ec2.DescribeNetworkInterfaces(request)
+	if err != nil {
+		return nil, err
+	}
+	if len(eni.NetworkInterfaces) == 0 {
+		return nil, nil
+	}
+	if len(eni.NetworkInterfaces) != 1 {
+		// This should not be possible - ids should be unique
+		return nil, fmt.Errorf("multiple interfaces found with same id %q", eni.NetworkInterfaces)
+	}
+	return eni.NetworkInterfaces[0], nil
+}
diff --git a/staging/src/k8s.io/legacy-cloud-providers/aws/aws_fakes.go b/staging/src/k8s.io/legacy-cloud-providers/aws/aws_fakes.go
index 0113c55554f..b0662072f43 100644
--- a/staging/src/k8s.io/legacy-cloud-providers/aws/aws_fakes.go
+++ b/staging/src/k8s.io/legacy-cloud-providers/aws/aws_fakes.go
@@ -310,6 +310,35 @@ func (ec2i *FakeEC2Impl) DescribeVpcs(request *ec2.DescribeVpcsInput) (*ec2.Desc
 	return &ec2.DescribeVpcsOutput{Vpcs: []*ec2.Vpc{{CidrBlock: aws.String("172.20.0.0/16")}}}, nil
 }
 
+// DescribeNetworkInterfaces returns list of ENIs for testing
+func (ec2i *FakeEC2Impl) DescribeNetworkInterfaces(input *ec2.DescribeNetworkInterfacesInput) (*ec2.DescribeNetworkInterfacesOutput, error) {
+	for _, filter := range input.Filters {
+		if *filter.Name == "private-dns-name" {
+			if strings.HasPrefix(*filter.Values[0], fargateNodeNamePrefix) {
+				panic("Invalid privateDNSName specified for DescribeNetworkInterface call")
+			}
+		}
+	}
+	networkInterface := []*ec2.NetworkInterface{
+		{
+			PrivateIpAddress: aws.String("1.2.3.4"),
+			AvailabilityZone: aws.String("us-west-2b"),
+			VpcId:            aws.String("vpc-123456"),
+			SubnetId:         aws.String("subnet-123456"),
+		},
+	}
+	for _, filter := range input.Filters {
+		// if filter contains privateDnsName then add privateDNSName to output
+		if *filter.Name == "private-dns-name" {
+			networkInterface[0].PrivateDnsName = aws.String("ip-1-2-3-4.compute.amazon.com")
+		}
+	}
+
+	return &ec2.DescribeNetworkInterfacesOutput{
+		NetworkInterfaces: networkInterface,
+	}, nil
+}
+
 // FakeMetadata is a fake EC2 metadata service client used for testing
 type FakeMetadata struct {
 	aws *FakeAWSServices
diff --git a/staging/src/k8s.io/legacy-cloud-providers/aws/aws_routes.go b/staging/src/k8s.io/legacy-cloud-providers/aws/aws_routes.go
index ed6e276cb22..cdbe1f1664c 100644
--- a/staging/src/k8s.io/legacy-cloud-providers/aws/aws_routes.go
+++ b/staging/src/k8s.io/legacy-cloud-providers/aws/aws_routes.go
@@ -143,14 +143,14 @@ func (c *Cloud) configureInstanceSourceDestCheck(instanceID string, sourceDestCh
 // CreateRoute implements Routes.CreateRoute
 // Create the described route
 func (c *Cloud) CreateRoute(ctx context.Context, clusterName string, nameHint string, route *cloudprovider.Route) error {
-	instance, err := c.getInstanceByNodeName(route.TargetNode)
+	instance, err := c.getAwsInstanceByNodeName(route.TargetNode)
 	if err != nil {
 		return err
 	}
 
 	// In addition to configuring the route itself, we also need to configure the instance to accept that traffic
 	// On AWS, this requires turning source-dest checks off
-	err = c.configureInstanceSourceDestCheck(aws.StringValue(instance.InstanceId), false)
+	err = c.configureInstanceSourceDestCheck(instance.awsID, false)
 	if err != nil {
 		return err
 	}
@@ -189,7 +189,7 @@ func (c *Cloud) CreateRoute(ctx context.Context, clusterName string, nameHint st
 	request := &ec2.CreateRouteInput{}
 	// TODO: use ClientToken for idempotency?
 	request.DestinationCidrBlock = aws.String(route.DestinationCIDR)
-	request.InstanceId = instance.InstanceId
+	request.InstanceId = aws.String(instance.awsID)
 	request.RouteTableId = table.RouteTableId
 
 	_, err = c.ec2.CreateRoute(request)
diff --git a/staging/src/k8s.io/legacy-cloud-providers/aws/aws_test.go b/staging/src/k8s.io/legacy-cloud-providers/aws/aws_test.go
index bc6cb1b18ac..d0d05d76603 100644
--- a/staging/src/k8s.io/legacy-cloud-providers/aws/aws_test.go
+++ b/staging/src/k8s.io/legacy-cloud-providers/aws/aws_test.go
@@ -1516,20 +1516,20 @@ func TestFindInstanceByNodeNameExcludesTerminatedInstances(t *testing.T) {
 			return
 		}
 
-		resultInstance, err := c.findInstanceByNodeName(nodeName)
+		resultInstance, err := c.findAwsInstanceByNodeName(nodeName)
 
 		if awsState.expected {
 			if err != nil || resultInstance == nil {
 				t.Errorf("Expected to find instance %v", *testInstance.InstanceId)
 				return
 			}
-			if *resultInstance.InstanceId != *testInstance.InstanceId {
-				t.Errorf("Wrong instance returned by findInstanceByNodeName() expected: %v, actual: %v", *testInstance.InstanceId, *resultInstance.InstanceId)
+			if resultInstance.awsID != *testInstance.InstanceId {
+				t.Errorf("Wrong instance returned by findInstanceByNodeName() expected: %v, actual: %v", *testInstance.InstanceId, resultInstance.awsID)
 				return
 			}
 		} else {
 			if err == nil && resultInstance != nil {
-				t.Errorf("Did not expect to find instance %v", *resultInstance.InstanceId)
+				t.Errorf("Did not expect to find instance %v", resultInstance.awsID)
 				return
 			}
 		}
@@ -3538,3 +3538,57 @@ func Test_parseStringSliceAnnotation(t *testing.T) {
 		})
 	}
 }
+
+func TestNodeAddressesForFargate(t *testing.T) {
+	awsServices := newMockedFakeAWSServices(TestClusterID)
+	c, _ := newAWSCloud(CloudConfig{}, awsServices)
+	c.cfg.Global.IPAddress = "1.2.3.4"
+	c.cfg.Global.PrivateDNSName = "ip-1-2-3-4.compute.amazon.com"
+
+	nodeAddresses, _ := c.NodeAddresses(context.TODO(), "fargate-ip-1-2-3-4.compute.amazon.com")
+	verifyNodeAddressesForFargate(t, nodeAddresses)
+}
+
+func TestBuildFargateTaskFromDescribeNetworkInterfaces(t *testing.T) {
+	awsServices := newMockedFakeAWSServices(TestClusterID)
+	c, _ := newAWSCloud(CloudConfig{}, awsServices)
+	c.cfg.Global.ProviderIDPrefix = "fargateTest"
+
+	awsInstance, _ := c.buildAWSInstanceForFargateNode("fargate-ip-1-2-3-4.compute.amazon.com")
+	assert.Equal(t, "vpc-123456", awsInstance.vpcID)
+	assert.Equal(t, "subnet-123456", awsInstance.subnetID)
+	assert.Equal(t, "1.2.3.4", awsInstance.addresses[0].Address)
+	assert.Equal(t, "us-west-2b", awsInstance.availabilityZone)
+	assert.Equal(t, "fargateTest/fargate-ip-1-2-3-4.compute.amazon.com", awsInstance.awsID)
+}
+
+func TestNodeAddressesByProviderIDForFargate(t *testing.T) {
+	awsServices := newMockedFakeAWSServices(TestClusterID)
+	c, _ := newAWSCloud(CloudConfig{}, awsServices)
+	c.cfg.Global.IPAddress = "1.2.3.4"
+	c.cfg.Global.PrivateDNSName = "ip-1-2-3-4.compute.amazon.com"
+
+	nodeAddresses, _ := c.NodeAddressesByProviderID(context.TODO(), "fargateTest/fargate-ip-1-2-3-4.compute.amazon.com")
+	verifyNodeAddressesForFargate(t, nodeAddresses)
+}
+
+func verifyNodeAddressesForFargate(t *testing.T, nodeAddresses []v1.NodeAddress) {
+	assert.Equal(t, 2, len(nodeAddresses))
+	assert.Equal(t, "1.2.3.4", nodeAddresses[0].Address)
+	assert.Equal(t, v1.NodeInternalIP, nodeAddresses[0].Type)
+	assert.Equal(t, "ip-1-2-3-4.compute.amazon.com", nodeAddresses[1].Address)
+	assert.Equal(t, v1.NodeInternalDNS, nodeAddresses[1].Type)
+}
+
+func TestBuildFargateTaskUsingPrivateIpFromDescribeNetworkInterfaces(t *testing.T) {
+	awsServices := newMockedFakeAWSServices(TestClusterID)
+	c, _ := newAWSCloud(CloudConfig{}, awsServices)
+	c.cfg.Global.ProviderIDPrefix = "fargateTest"
+	nodeName := "fargate-1.2.3.4"
+
+	awsInstance, _ := c.buildAWSInstanceForFargateNode(nodeName)
+	assert.Equal(t, "1.2.3.4", awsInstance.addresses[0].Address)
+	assert.Equal(t, string(awsInstance.nodeName), nodeName)
+	assert.Equal(t, "fargateTest/fargate-1.2.3.4", awsInstance.awsID)
+	assert.Equal(t, 1, len(awsInstance.addresses))
+}
diff --git a/staging/src/k8s.io/legacy-cloud-providers/aws/instances.go b/staging/src/k8s.io/legacy-cloud-providers/aws/instances.go
index a62e7ccf395..741b1b7638c 100644
--- a/staging/src/k8s.io/legacy-cloud-providers/aws/instances.go
+++ b/staging/src/k8s.io/legacy-cloud-providers/aws/instances.go
@@ -73,17 +73,13 @@ func (name KubernetesInstanceID) MapToAWSInstanceID() (InstanceID, error) {
 
 	awsID := ""
 	tokens := strings.Split(strings.Trim(url.Path, "/"), "/")
-	if len(tokens) == 1 {
-		// instanceId
-		awsID = tokens[0]
-	} else if len(tokens) == 2 {
-		// az/instanceId
-		awsID = tokens[1]
+	if len(tokens) > 0 {
+		awsID = tokens[len(tokens)-1]
 	}
 
-	// We sanity check the resulting volume; the two known formats are
-	// i-12345678 and i-12345678abcdef01
-	if awsID == "" || !awsInstanceRegMatch.MatchString(awsID) {
+	// We sanity check the resulting volume; the known formats are
+	// i-12345678, i-12345678abcdef01 and fargate-dnsName
+	if awsID == "" || !(awsInstanceRegMatch.MatchString(awsID) || isFargateNode(awsID)) {
 		return "", fmt.Errorf("Invalid format for AWS instance (%s)", name)
 	}
 
