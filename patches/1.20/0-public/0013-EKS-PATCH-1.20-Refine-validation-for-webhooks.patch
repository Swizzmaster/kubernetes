From 68e38af9813e5f1474bf239e77c7e50a8e3cdca6 Mon Sep 17 00:00:00 2001
From: Shravan Achar <balakund@amazon.com>
Date: Wed, 10 Mar 2021 12:59:06 -0800
Subject: [PATCH] --EKS-PATCH--<=1.20- Refine validation for webhooks

Upstream PR: https://github.com/kubernetes/kubernetes/pull/99946

EKS Internal only patch. Not marked for public distribution on
EKS-Distro

This patch is not needed for 1.21+

cr https://code.amazon.com/reviews/CR-46926344
---
 hack/make-rules/verify.sh                     |   1 +
 hack/verify-non-mutating-validation.sh        |  41 +++++
 pkg/apis/core/fuzzer/BUILD                    |   2 +
 pkg/apis/core/fuzzer/fuzzer.go                |  47 ++++-
 pkg/apis/core/validation/BUILD                |   9 +
 pkg/apis/core/validation/mutation_test.go     | 163 ++++++++++++++++++
 .../apimachinery/pkg/api/apitesting/BUILD     |   1 +
 .../api/apitesting/validationtesting/BUILD    |  30 ++++
 .../validationtesting/validation.go           | 153 ++++++++++++++++
 .../apitesting/validationtesting/wrapper.go   | 132 ++++++++++++++
 .../pkg/apis/meta/fuzzer/fuzzer.go            |  24 ++-
 11 files changed, 600 insertions(+), 3 deletions(-)
 create mode 100755 hack/verify-non-mutating-validation.sh
 create mode 100644 pkg/apis/core/validation/mutation_test.go
 create mode 100644 staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting/BUILD
 create mode 100644 staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting/validation.go
 create mode 100644 staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting/wrapper.go

diff --git a/hack/make-rules/verify.sh b/hack/make-rules/verify.sh
index 12fb78d5b98..0dce9a50ad5 100755
--- a/hack/make-rules/verify.sh
+++ b/hack/make-rules/verify.sh
@@ -82,6 +82,7 @@ QUICK_PATTERNS+=(
   "verify-vendor-licenses.sh"
   "verify-gofmt.sh"
   "verify-imports.sh"
+  "verify-non-mutating-validation.sh"
   "verify-pkg-names.sh"
   "verify-readonly-packages.sh"
   "verify-spelling.sh"
diff --git a/hack/verify-non-mutating-validation.sh b/hack/verify-non-mutating-validation.sh
new file mode 100755
index 00000000000..5fe3bed2146
--- /dev/null
+++ b/hack/verify-non-mutating-validation.sh
@@ -0,0 +1,41 @@
+#!/usr/bin/env bash
+
+# Copyright 2020 The Kubernetes Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# This script checks that validation files do not mutate their inputs.
+# Usage: `hack/verify-non-mutating-validation.sh`.
+
+set -o errexit
+set -o nounset
+set -o pipefail
+
+KUBE_ROOT=$(dirname "${BASH_SOURCE[0]}")/..
+source "${KUBE_ROOT}/hack/lib/init.sh"
+
+mutationOutput=$(find . -name validation.go | xargs egrep -n ' = old' | grep -v '// +k8s:verify-mutation:reason=clone' || true)
+foundMutation=$(echo "${mutationOutput}" | wc -c)
+# when there's no match, there is a newline
+if [ "$foundMutation" -gt "1" ]; then
+  echo "${mutationOutput}"
+  exit 1
+fi
+
+mutationOutput=$(! find . -name validation.go | xargs egrep -n 'old.* = ' | grep -v '// +k8s:verify-mutation:reason=clone' || true)
+foundMutation=$(echo "${mutationOutput}" | wc -l)
+# when there's no match, there is a newline
+if [ "$foundMutation" -gt "1" ]; then
+  echo "${mutationOutput}"
+  exit 1
+fi
diff --git a/pkg/apis/core/fuzzer/BUILD b/pkg/apis/core/fuzzer/BUILD
index c30003bbdd7..963c2fbe312 100644
--- a/pkg/apis/core/fuzzer/BUILD
+++ b/pkg/apis/core/fuzzer/BUILD
@@ -13,11 +13,13 @@ go_library(
         "//pkg/apis/core:go_default_library",
         "//staging/src/k8s.io/api/core/v1:go_default_library",
         "//staging/src/k8s.io/apimachinery/pkg/api/resource:go_default_library",
+        "//staging/src/k8s.io/apimachinery/pkg/apis/meta/fuzzer:go_default_library",
         "//staging/src/k8s.io/apimachinery/pkg/apis/meta/v1:go_default_library",
         "//staging/src/k8s.io/apimachinery/pkg/runtime:go_default_library",
         "//staging/src/k8s.io/apimachinery/pkg/runtime/schema:go_default_library",
         "//staging/src/k8s.io/apimachinery/pkg/runtime/serializer:go_default_library",
         "//staging/src/k8s.io/apimachinery/pkg/util/intstr:go_default_library",
+        "//staging/src/k8s.io/apimachinery/pkg/util/uuid:go_default_library",
         "//vendor/github.com/google/gofuzz:go_default_library",
     ],
 )
diff --git a/pkg/apis/core/fuzzer/fuzzer.go b/pkg/apis/core/fuzzer/fuzzer.go
index 43c4943474f..f025eda3698 100644
--- a/pkg/apis/core/fuzzer/fuzzer.go
+++ b/pkg/apis/core/fuzzer/fuzzer.go
@@ -21,10 +21,12 @@ import (
 	"strconv"
 	"time"
 
-	fuzz "github.com/google/gofuzz"
+	"k8s.io/apimachinery/pkg/util/uuid"
 
+	fuzz "github.com/google/gofuzz"
 	corev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/api/resource"
+	metafuzzer "k8s.io/apimachinery/pkg/apis/meta/fuzzer"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/runtime/schema"
@@ -301,6 +303,35 @@ var Funcs = func(codecs runtimeserializer.CodecFactory) []interface{} {
 			ct.TerminationMessagePath = "/" + ct.TerminationMessagePath // Must be non-empty
 			ct.TerminationMessagePolicy = "File"
 		},
+		func(p *core.Taint, c fuzz.Continue) {
+			c.FuzzNoCustom(p) // fuzz self without calling this function again
+			if p == nil {
+				return
+			}
+
+			p.Key = metafuzzer.RandomDNSLabel(c)
+			switch c.Rand.Int31n(3) {
+			case 0:
+				p.Effect = core.TaintEffectNoSchedule
+			case 1:
+				p.Effect = core.TaintEffectNoExecute
+			case 2:
+				p.Effect = core.TaintEffectPreferNoSchedule
+			}
+			p.Value = metafuzzer.RandomDNSLabel(c)
+		},
+		func(p *core.ConfigMapNodeConfigSource, c fuzz.Continue) {
+			c.FuzzNoCustom(p) // fuzz self without calling this function again
+			if p == nil {
+				return
+			}
+
+			p.UID = ""
+			p.ResourceVersion = ""
+			p.Name = metafuzzer.RandomDNSLabel(c)
+			p.Namespace = metafuzzer.RandomDNSLabel(c)
+			p.KubeletConfigKey = metafuzzer.RandomDNSLabel(c)
+		},
 		func(ep *core.EphemeralContainer, c fuzz.Continue) {
 			c.FuzzNoCustom(ep)                                                                   // fuzz self without calling this function again
 			ep.EphemeralContainerCommon.TerminationMessagePath = "/" + ep.TerminationMessagePath // Must be non-empty
@@ -511,7 +542,21 @@ var Funcs = func(codecs runtimeserializer.CodecFactory) []interface{} {
 		},
 		func(s *core.NodeStatus, c fuzz.Continue) {
 			c.FuzzNoCustom(s)
+
 			s.Allocatable = s.Capacity
+
+			if s.Config != nil && s.Config.LastKnownGood != nil && s.Config.LastKnownGood.ConfigMap != nil {
+				s.Config.LastKnownGood.ConfigMap.UID = uuid.NewUUID()
+				s.Config.LastKnownGood.ConfigMap.ResourceVersion = c.RandString()
+			}
+			if s.Config != nil && s.Config.Assigned != nil && s.Config.Assigned.ConfigMap != nil {
+				s.Config.Assigned.ConfigMap.UID = uuid.NewUUID()
+				s.Config.Assigned.ConfigMap.ResourceVersion = c.RandString()
+			}
+			if s.Config != nil && s.Config.Active != nil && s.Config.Active.ConfigMap != nil {
+				s.Config.Active.ConfigMap.UID = uuid.NewUUID()
+				s.Config.Active.ConfigMap.ResourceVersion = c.RandString()
+			}
 		},
 		func(e *core.Event, c fuzz.Continue) {
 			c.FuzzNoCustom(e)
diff --git a/pkg/apis/core/validation/BUILD b/pkg/apis/core/validation/BUILD
index d65041ed49b..5873cd29f56 100644
--- a/pkg/apis/core/validation/BUILD
+++ b/pkg/apis/core/validation/BUILD
@@ -50,19 +50,28 @@ go_test(
     srcs = [
         "conditional_validation_test.go",
         "events_test.go",
+        "mutation_test.go",
         "validation_test.go",
     ],
     embed = [":go_default_library"],
     deps = [
+        "//pkg/api/legacyscheme:go_default_library",
         "//pkg/apis/core:go_default_library",
+        "//pkg/apis/core/fuzzer:go_default_library",
         "//pkg/capabilities:go_default_library",
         "//pkg/features:go_default_library",
         "//staging/src/k8s.io/api/core/v1:go_default_library",
         "//staging/src/k8s.io/api/events/v1:go_default_library",
         "//staging/src/k8s.io/api/events/v1beta1:go_default_library",
+        "//staging/src/k8s.io/apimachinery/pkg/api/apitesting/fuzzer:go_default_library",
+        "//staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting:go_default_library",
         "//staging/src/k8s.io/apimachinery/pkg/api/resource:go_default_library",
+        "//staging/src/k8s.io/apimachinery/pkg/apis/meta/fuzzer:go_default_library",
         "//staging/src/k8s.io/apimachinery/pkg/apis/meta/v1:go_default_library",
+        "//staging/src/k8s.io/apimachinery/pkg/runtime:go_default_library",
+        "//staging/src/k8s.io/apimachinery/pkg/util/diff:go_default_library",
         "//staging/src/k8s.io/apimachinery/pkg/util/intstr:go_default_library",
+        "//staging/src/k8s.io/apimachinery/pkg/util/runtime:go_default_library",
         "//staging/src/k8s.io/apimachinery/pkg/util/validation:go_default_library",
         "//staging/src/k8s.io/apimachinery/pkg/util/validation/field:go_default_library",
         "//staging/src/k8s.io/apiserver/pkg/util/feature:go_default_library",
diff --git a/pkg/apis/core/validation/mutation_test.go b/pkg/apis/core/validation/mutation_test.go
new file mode 100644
index 00000000000..2a3dcc66cce
--- /dev/null
+++ b/pkg/apis/core/validation/mutation_test.go
@@ -0,0 +1,163 @@
+/*
+Copyright 2021 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package validation
+
+import (
+	"math/rand"
+	"reflect"
+	"testing"
+	"time"
+
+	"k8s.io/apimachinery/pkg/api/apitesting/fuzzer"
+	"k8s.io/apimachinery/pkg/api/apitesting/validationtesting"
+	metafuzzer "k8s.io/apimachinery/pkg/apis/meta/fuzzer"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/util/diff"
+	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
+	"k8s.io/kubernetes/pkg/api/legacyscheme"
+	coreapi "k8s.io/kubernetes/pkg/apis/core"
+	corefuzzer "k8s.io/kubernetes/pkg/apis/core/fuzzer"
+)
+
+func getScheme() *runtime.Scheme {
+	scheme := &runtime.Scheme{}
+	utilruntime.Must(coreapi.AddToScheme(scheme))
+	return scheme
+}
+
+func getValidators() *validationtesting.RuntimeObjectsValidator {
+	validator := validationtesting.NewRuntimeObjectsValidator()
+
+	validator.MustRegister(&coreapi.Node{}, false, ValidateNode, ValidateNodeUpdate)
+	return validator
+}
+
+type validateUpdateCheck struct {
+	obj    runtime.Object
+	oldObj runtime.Object
+}
+
+func newClusterScopedObjectMeta(name string) metav1.ObjectMeta {
+	seed := time.Now().UnixNano()
+	fuzzer := fuzzer.FuzzerFor(metafuzzer.Funcs, rand.NewSource(seed), legacyscheme.Codecs)
+
+	objMeta := metav1.ObjectMeta{}
+	fuzzer.Fuzz(&objMeta)
+	objMeta.Name = name
+	objMeta.Namespace = ""
+	// we don't validate these in this method
+	objMeta.ManagedFields = nil
+
+	return objMeta
+}
+
+func newClusterScopedObjectMetaUpdate(oldObjMeta metav1.ObjectMeta) metav1.ObjectMeta {
+	oldObjMetaCopy := oldObjMeta.DeepCopy()
+	seed := time.Now().UnixNano()
+	fuzzer := fuzzer.FuzzerFor(metafuzzer.Funcs, rand.NewSource(seed), legacyscheme.Codecs)
+
+	objMeta := metav1.ObjectMeta{}
+	fuzzer.Fuzz(&objMeta)
+
+	// many fields are immutable
+	objMeta.Name = oldObjMetaCopy.Name
+	objMeta.Namespace = oldObjMetaCopy.Namespace
+	objMeta.UID = oldObjMetaCopy.UID
+	objMeta.CreationTimestamp = oldObjMetaCopy.CreationTimestamp
+	objMeta.DeletionTimestamp = oldObjMetaCopy.DeletionTimestamp
+	objMeta.DeletionGracePeriodSeconds = oldObjMetaCopy.DeletionGracePeriodSeconds
+	objMeta.ClusterName = oldObjMetaCopy.ClusterName
+	objMeta.Generation = oldObjMetaCopy.Generation
+	objMeta.ManagedFields = oldObjMetaCopy.ManagedFields
+
+	return objMeta
+}
+
+func newNode(name string) *coreapi.Node {
+	ret := &coreapi.Node{}
+	seed := time.Now().UnixNano()
+	fuzzer := fuzzer.FuzzerFor(
+		fuzzer.MergeFuzzerFuncs(metafuzzer.Funcs, corefuzzer.Funcs),
+		rand.NewSource(seed), legacyscheme.Codecs)
+	fuzzer.Fuzz(ret)
+
+	ret.ObjectMeta = newClusterScopedObjectMeta(name)
+
+	return ret
+}
+
+func newNodeUpdate(node *coreapi.Node) *coreapi.Node {
+	ret := &coreapi.Node{}
+	seed := time.Now().UnixNano()
+	fuzzer := fuzzer.FuzzerFor(
+		fuzzer.MergeFuzzerFuncs(metafuzzer.Funcs, corefuzzer.Funcs),
+		rand.NewSource(seed), legacyscheme.Codecs)
+	fuzzer.Fuzz(ret)
+
+	nodeCopy := node.DeepCopy()
+	ret.ObjectMeta = newClusterScopedObjectMetaUpdate(nodeCopy.ObjectMeta)
+	ret.Spec.ProviderID = nodeCopy.Spec.ProviderID
+	ret.Spec.PodCIDRs = nodeCopy.Spec.PodCIDRs
+	ret.Spec.ConfigSource = nodeCopy.Spec.ConfigSource
+	ret.Spec.DoNotUseExternalID = nodeCopy.Spec.DoNotUseExternalID
+
+	return ret
+}
+
+func newNodeValidationUpdateCheck() validateUpdateCheck {
+	old := newNode("the-node")
+	return validateUpdateCheck{
+		obj:    newNodeUpdate(old),
+		oldObj: old,
+	}
+}
+
+// this test checks to see if validateUpdate mutates its arguments
+func TestMutationValidateUpdate(t *testing.T) {
+	validators := getValidators()
+
+	// only test node now, but this is a proof of concept for overall enforcement
+	mutationObjects := []validateUpdateCheck{
+		newNodeValidationUpdateCheck(),
+	}
+
+	for _, tt := range mutationObjects {
+		typeName := reflect.TypeOf(tt.obj)
+		for i := 0; i < 20; i++ {
+			t.Run(typeName.Name(), func(t *testing.T) {
+				validator, exists := validators.GetInfo(tt.obj)
+				if !exists {
+					t.Fatal("missing validation func")
+				}
+
+				originalObj := tt.obj.DeepCopyObject()
+				originalOldObj := tt.oldObj.DeepCopyObject()
+				errors := validator.Validator.ValidateUpdate(tt.obj, tt.oldObj)
+				if len(errors) > 0 {
+					t.Fatal(errors)
+				}
+				if !reflect.DeepEqual(tt.oldObj, originalOldObj) {
+					t.Errorf("mutation of oldObject:\n%v", diff.ObjectGoPrintDiff(originalOldObj, tt.oldObj))
+				}
+				if !reflect.DeepEqual(tt.obj, originalObj) {
+					t.Errorf("mutation of oldObject:\n%v", diff.ObjectGoPrintDiff(originalObj, tt.obj))
+				}
+			})
+		}
+	}
+}
diff --git a/staging/src/k8s.io/apimachinery/pkg/api/apitesting/BUILD b/staging/src/k8s.io/apimachinery/pkg/api/apitesting/BUILD
index 6144d9be6e4..8abac47d9d1 100644
--- a/staging/src/k8s.io/apimachinery/pkg/api/apitesting/BUILD
+++ b/staging/src/k8s.io/apimachinery/pkg/api/apitesting/BUILD
@@ -32,6 +32,7 @@ filegroup(
         "//staging/src/k8s.io/apimachinery/pkg/api/apitesting/fuzzer:all-srcs",
         "//staging/src/k8s.io/apimachinery/pkg/api/apitesting/naming:all-srcs",
         "//staging/src/k8s.io/apimachinery/pkg/api/apitesting/roundtrip:all-srcs",
+        "//staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting:all-srcs",
     ],
     tags = ["automanaged"],
 )
diff --git a/staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting/BUILD b/staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting/BUILD
new file mode 100644
index 00000000000..0570f81a3f6
--- /dev/null
+++ b/staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting/BUILD
@@ -0,0 +1,30 @@
+load("@io_bazel_rules_go//go:def.bzl", "go_library")
+
+go_library(
+    name = "go_default_library",
+    srcs = [
+        "validation.go",
+        "wrapper.go",
+    ],
+    importmap = "k8s.io/kubernetes/vendor/k8s.io/apimachinery/pkg/api/apitesting/validationtesting",
+    importpath = "k8s.io/apimachinery/pkg/api/apitesting/validationtesting",
+    visibility = ["//visibility:public"],
+    deps = [
+        "//staging/src/k8s.io/apimachinery/pkg/runtime:go_default_library",
+        "//staging/src/k8s.io/apimachinery/pkg/util/validation/field:go_default_library",
+    ],
+)
+
+filegroup(
+    name = "package-srcs",
+    srcs = glob(["**"]),
+    tags = ["automanaged"],
+    visibility = ["//visibility:private"],
+)
+
+filegroup(
+    name = "all-srcs",
+    srcs = [":package-srcs"],
+    tags = ["automanaged"],
+    visibility = ["//visibility:public"],
+)
diff --git a/staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting/validation.go b/staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting/validation.go
new file mode 100644
index 00000000000..6f751b04cf3
--- /dev/null
+++ b/staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting/validation.go
@@ -0,0 +1,153 @@
+/*
+Copyright 2021 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package validationtesting
+
+import (
+	"fmt"
+	"reflect"
+
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/util/validation/field"
+)
+
+type RuntimeObjectValidator interface {
+	Validate(obj runtime.Object) field.ErrorList
+	ValidateUpdate(obj, old runtime.Object) field.ErrorList
+}
+
+type RuntimeObjectsValidator struct {
+	typeToValidator map[reflect.Type]RuntimeObjectValidatorInfo
+}
+
+func NewRuntimeObjectsValidator() *RuntimeObjectsValidator {
+	return &RuntimeObjectsValidator{map[reflect.Type]RuntimeObjectValidatorInfo{}}
+}
+
+type RuntimeObjectValidatorInfo struct {
+	Validator     RuntimeObjectValidator
+	IsNamespaced  bool
+	HasObjectMeta bool
+	UpdateAllowed bool
+}
+
+func (v *RuntimeObjectsValidator) GetInfoForType(apiType reflect.Type) (RuntimeObjectValidatorInfo, bool) {
+	ptrType := reflect.PtrTo(apiType)
+
+	ret, ok := v.typeToValidator[ptrType]
+	return ret, ok
+}
+
+func (v *RuntimeObjectsValidator) GetInfo(obj runtime.Object) (RuntimeObjectValidatorInfo, bool) {
+	ret, ok := v.typeToValidator[reflect.TypeOf(obj)]
+	return ret, ok
+}
+
+func (v *RuntimeObjectsValidator) MustRegister(obj runtime.Object, namespaceScoped bool, validateFunction interface{}, validateUpdateFunction interface{}) {
+	if err := v.Register(obj, namespaceScoped, validateFunction, validateUpdateFunction); err != nil {
+		panic(err)
+	}
+}
+
+func (v *RuntimeObjectsValidator) Register(obj runtime.Object, namespaceScoped bool, validateFunction interface{}, validateUpdateFunction interface{}) error {
+	objType := reflect.TypeOf(obj)
+	if oldValidator, exists := v.typeToValidator[objType]; exists {
+		panic(fmt.Sprintf("%v is already registered with %v", objType, oldValidator))
+	}
+
+	validator, err := NewValidationWrapper(validateFunction, validateUpdateFunction)
+	if err != nil {
+		return err
+	}
+
+	updateAllowed := validateUpdateFunction != nil
+
+	v.typeToValidator[objType] = RuntimeObjectValidatorInfo{validator, namespaceScoped, HasObjectMeta(obj), updateAllowed}
+
+	return nil
+}
+
+func (v *RuntimeObjectsValidator) Validate(obj runtime.Object) field.ErrorList {
+	if obj == nil {
+		return field.ErrorList{}
+	}
+
+	allErrs := field.ErrorList{}
+
+	specificValidationInfo, err := v.getSpecificValidationInfo(obj)
+	if err != nil {
+		allErrs = append(allErrs, field.InternalError(nil, err))
+		return allErrs
+	}
+
+	allErrs = append(allErrs, specificValidationInfo.Validator.Validate(obj)...)
+	return allErrs
+}
+
+func (v *RuntimeObjectsValidator) ValidateUpdate(obj, old runtime.Object) field.ErrorList {
+	if obj == nil && old == nil {
+		return field.ErrorList{}
+	}
+	if newType, oldType := reflect.TypeOf(obj), reflect.TypeOf(old); newType != oldType {
+		return field.ErrorList{field.Invalid(field.NewPath("kind"), newType.Kind(), fmt.Sprintf("expected type %s, for field %s, got %s", oldType.Kind().String(), "kind", newType.Kind().String()))}
+	}
+
+	allErrs := field.ErrorList{}
+
+	specificValidationInfo, err := v.getSpecificValidationInfo(obj)
+	if err != nil {
+		if fieldErr, ok := err.(*field.Error); ok {
+			allErrs = append(allErrs, fieldErr)
+		} else {
+			allErrs = append(allErrs, field.InternalError(nil, err))
+		}
+		return allErrs
+	}
+
+	allErrs = append(allErrs, specificValidationInfo.Validator.ValidateUpdate(obj, old)...)
+
+	// no errors so far, make sure that the new object is actually valid against the original validator
+	if len(allErrs) == 0 {
+		allErrs = append(allErrs, specificValidationInfo.Validator.Validate(obj)...)
+	}
+
+	return allErrs
+}
+
+func (v *RuntimeObjectsValidator) getSpecificValidationInfo(obj runtime.Object) (RuntimeObjectValidatorInfo, error) {
+	objType := reflect.TypeOf(obj)
+	specificValidationInfo, exists := v.typeToValidator[objType]
+	if !exists {
+		return RuntimeObjectValidatorInfo{}, fmt.Errorf("no validator registered for %v", objType)
+	}
+
+	return specificValidationInfo, nil
+}
+
+func (v *RuntimeObjectsValidator) GetRequiresNamespace(obj runtime.Object) (bool, error) {
+	objType := reflect.TypeOf(obj)
+	specificValidationInfo, exists := v.typeToValidator[objType]
+	if !exists {
+		return false, fmt.Errorf("no validator registered for %v", objType)
+	}
+
+	return specificValidationInfo.IsNamespaced, nil
+}
+
+func HasObjectMeta(obj runtime.Object) bool {
+	objValue := reflect.ValueOf(obj).Elem()
+	return objValue.FieldByName("ObjectMeta").IsValid()
+}
diff --git a/staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting/wrapper.go b/staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting/wrapper.go
new file mode 100644
index 00000000000..e7b1d48b7e6
--- /dev/null
+++ b/staging/src/k8s.io/apimachinery/pkg/api/apitesting/validationtesting/wrapper.go
@@ -0,0 +1,132 @@
+/*
+Copyright 2021 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package validationtesting
+
+import (
+	"fmt"
+	"reflect"
+
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/util/validation/field"
+)
+
+type WrappingValidator struct {
+	validate       *reflect.Value
+	validateUpdate *reflect.Value
+}
+
+func (v *WrappingValidator) Validate(obj runtime.Object) field.ErrorList {
+	return callValidate(reflect.ValueOf(obj), *v.validate)
+}
+
+func (v *WrappingValidator) ValidateUpdate(obj, old runtime.Object) field.ErrorList {
+	if v.validateUpdate == nil {
+		// if there is no update validation, fail.
+		return field.ErrorList{field.Forbidden(field.NewPath("obj"), fmt.Sprintf("%v", obj))}
+	}
+
+	return callValidateUpdate(reflect.ValueOf(obj), reflect.ValueOf(old), *v.validateUpdate)
+}
+
+func NewValidationWrapper(validateFunction interface{}, validateUpdateFunction interface{}) (*WrappingValidator, error) {
+	validateFunctionValue := reflect.ValueOf(validateFunction)
+	validateType := validateFunctionValue.Type()
+	if err := verifyValidateFunctionSignature(validateType); err != nil {
+		return nil, err
+	}
+
+	var validateUpdateFunctionValue *reflect.Value
+	if validateUpdateFunction != nil {
+		functionValue := reflect.ValueOf(validateUpdateFunction)
+		validateUpdateType := functionValue.Type()
+		if err := verifyValidateUpdateFunctionSignature(validateUpdateType); err != nil {
+			return nil, err
+		}
+
+		validateUpdateFunctionValue = &functionValue
+	}
+
+	return &WrappingValidator{&validateFunctionValue, validateUpdateFunctionValue}, nil
+}
+
+func verifyValidateFunctionSignature(ft reflect.Type) error {
+	if ft.Kind() != reflect.Func {
+		return fmt.Errorf("expected func, got: %v", ft)
+	}
+	if ft.NumIn() != 1 {
+		return fmt.Errorf("expected one 'in' param, got: %v", ft)
+	}
+	if ft.NumOut() != 1 {
+		return fmt.Errorf("expected one 'out' param, got: %v", ft)
+	}
+	if ft.In(0).Kind() != reflect.Ptr {
+		return fmt.Errorf("expected pointer arg for 'in' param 0, got: %v", ft)
+	}
+	errorType := reflect.TypeOf(&field.ErrorList{}).Elem()
+	if ft.Out(0) != errorType {
+		return fmt.Errorf("expected field.ErrorList return, got: %v", ft)
+	}
+	return nil
+}
+
+func verifyValidateUpdateFunctionSignature(ft reflect.Type) error {
+	if ft.Kind() != reflect.Func {
+		return fmt.Errorf("expected func, got: %v", ft)
+	}
+	if ft.NumIn() != 2 {
+		return fmt.Errorf("expected two 'in' params, got: %v", ft)
+	}
+	if ft.NumOut() != 1 {
+		return fmt.Errorf("expected one 'out' param, got: %v", ft)
+	}
+	if ft.In(0).Kind() != reflect.Ptr {
+		return fmt.Errorf("expected pointer arg for 'in' param 0, got: %v", ft)
+	}
+	if ft.In(1).Kind() != reflect.Ptr {
+		return fmt.Errorf("expected pointer arg for 'in' param 1, got: %v", ft)
+	}
+	errorType := reflect.TypeOf(&field.ErrorList{}).Elem()
+	if ft.Out(0) != errorType {
+		return fmt.Errorf("expected field.ErrorList return, got: %v", ft)
+	}
+	return nil
+}
+
+// callCustom calls 'custom' with sv & dv. custom must be a conversion function.
+func callValidate(obj, validateMethod reflect.Value) field.ErrorList {
+	args := []reflect.Value{obj}
+	ret := validateMethod.Call(args)[0].Interface()
+
+	// This convolution is necessary because nil interfaces won't convert
+	// to errors.
+	if ret == nil {
+		return nil
+	}
+	return ret.(field.ErrorList)
+}
+
+func callValidateUpdate(obj, old, validateMethod reflect.Value) field.ErrorList {
+	args := []reflect.Value{obj, old}
+	ret := validateMethod.Call(args)[0].Interface()
+
+	// This convolution is necessary because nil interfaces won't convert
+	// to errors.
+	if ret == nil {
+		return nil
+	}
+	return ret.(field.ErrorList)
+}
diff --git a/staging/src/k8s.io/apimachinery/pkg/apis/meta/fuzzer/fuzzer.go b/staging/src/k8s.io/apimachinery/pkg/apis/meta/fuzzer/fuzzer.go
index bb5e8a2712d..5b2d1453526 100644
--- a/staging/src/k8s.io/apimachinery/pkg/apis/meta/fuzzer/fuzzer.go
+++ b/staging/src/k8s.io/apimachinery/pkg/apis/meta/fuzzer/fuzzer.go
@@ -137,7 +137,7 @@ func randomLabelPart(c fuzz.Continue, canBeEmpty bool) string {
 	return string(runes)
 }
 
-func randomDNSLabel(c fuzz.Continue) string {
+func RandomDNSLabel(c fuzz.Continue) string {
 	validStartEnd := []charRange{{'0', '9'}, {'a', 'z'}}
 	validMiddle := []charRange{{'0', '9'}, {'a', 'z'}, {'-', '-'}}
 
@@ -163,7 +163,7 @@ func randomLabelKey(c fuzz.Continue) string {
 		prefixPartsLen := c.Rand.Intn(2) + 1
 		prefixParts := make([]string, prefixPartsLen)
 		for i := range prefixParts {
-			prefixParts[i] = randomDNSLabel(c)
+			prefixParts[i] = RandomDNSLabel(c)
 		}
 		prefixPart = strings.Join(prefixParts, ".") + "/"
 	}
@@ -203,22 +203,42 @@ func v1FuzzerFuncs(codecs runtimeserializer.CodecFactory) []interface{} {
 			} else {
 				delete(j.Labels, "")
 			}
+			for k := range j.Labels {
+				j.Labels[RandomDNSLabel(c)] = randomLabelPart(c, true)
+				delete(j.Labels, k)
+			}
+
 			if len(j.Annotations) == 0 {
 				j.Annotations = nil
 			} else {
 				delete(j.Annotations, "")
 			}
+			for k := range j.Annotations {
+				j.Annotations[RandomDNSLabel(c)] = randomLabelPart(c, true)
+				delete(j.Annotations, k)
+			}
+
 			if len(j.OwnerReferences) == 0 {
 				j.OwnerReferences = nil
 			}
 			if len(j.Finalizers) == 0 {
 				j.Finalizers = nil
 			}
+			for i := 0; i < len(j.Finalizers); i++ {
+				j.Finalizers[i] = RandomDNSLabel(c) + "/" + RandomDNSLabel(c)
+			}
 		},
 		func(j *metav1.ResourceVersionMatch, c fuzz.Continue) {
 			matches := []metav1.ResourceVersionMatch{"", metav1.ResourceVersionMatchExact, metav1.ResourceVersionMatchNotOlderThan}
 			*j = matches[c.Rand.Intn(len(matches))]
 		},
+		func(j *metav1.OwnerReference, c fuzz.Continue) {
+			c.FuzzNoCustom(j)
+
+			if len(j.APIVersion) == 0 {
+				j.APIVersion = RandomDNSLabel(c)
+			}
+		},
 		func(j *metav1.ListMeta, c fuzz.Continue) {
 			j.ResourceVersion = strconv.FormatUint(c.RandUint64(), 10)
 			j.SelfLink = c.RandString()
