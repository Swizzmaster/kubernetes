From 92084a5579b0581bab17593a5af45291872dbef3 Mon Sep 17 00:00:00 2001
From: Micah Hausler <mhausler@amazon.com>
Date: Wed, 19 Sep 2018 18:16:23 -0700
Subject: [PATCH 1/2] [EKS-CHERRY-PICK] Added whitelist CIDR flag

---
 cmd/kube-apiserver/app/BUILD                 |  1 +
 cmd/kube-apiserver/app/dialer.go             | 46 ++++++++++++++
 cmd/kube-apiserver/app/options/BUILD         |  1 +
 cmd/kube-apiserver/app/options/options.go    | 27 ++++----
 cmd/kube-apiserver/app/options/validation.go | 15 +++++
 cmd/kube-apiserver/app/options/whitelist.go  |  9 +++
 cmd/kube-apiserver/app/server.go             |  7 +++
 pkg/kubeapiserver/options/BUILD              |  2 +
 pkg/kubeapiserver/options/ipnetslice.go      | 93 ++++++++++++++++++++++++++++
 pkg/kubeapiserver/options/ipnetslice_test.go | 36 +++++++++++
 pkg/kubeapiserver/options/options.go         |  2 +
 pkg/registry/core/node/BUILD                 |  1 +
 pkg/registry/core/node/strategy.go           | 14 +++++
 13 files changed, 243 insertions(+), 11 deletions(-)
 create mode 100644 cmd/kube-apiserver/app/dialer.go
 create mode 100644 cmd/kube-apiserver/app/options/whitelist.go
 create mode 100644 pkg/kubeapiserver/options/ipnetslice.go
 create mode 100644 pkg/kubeapiserver/options/ipnetslice_test.go

diff --git a/cmd/kube-apiserver/app/BUILD b/cmd/kube-apiserver/app/BUILD
index a053b2afae9..80b61048f1b 100644
--- a/cmd/kube-apiserver/app/BUILD
+++ b/cmd/kube-apiserver/app/BUILD
@@ -10,6 +10,7 @@ go_library(
     srcs = [
         "aggregator.go",
         "apiextensions.go",
+        "dialer.go",
         "server.go",
     ],
     importpath = "k8s.io/kubernetes/cmd/kube-apiserver/app",
diff --git a/cmd/kube-apiserver/app/dialer.go b/cmd/kube-apiserver/app/dialer.go
new file mode 100644
index 00000000000..5435c9b233b
--- /dev/null
+++ b/cmd/kube-apiserver/app/dialer.go
@@ -0,0 +1,46 @@
+package app
+
+import (
+	"context"
+	"crypto/tls"
+	"errors"
+	mathrand "math/rand"
+	"net"
+	"net/http"
+	"strings"
+	"time"
+
+	"github.com/golang/glog"
+
+	utilnet "k8s.io/apimachinery/pkg/util/net"
+	kubeoptions "k8s.io/kubernetes/pkg/kubeapiserver/options"
+)
+
+func CreateOutboundDialer(s completedServerRunOptions) (*http.Transport, error) {
+	proxyDialerFn := createWhitelistDialer(s.ServerRunOptions.ProxyCIDRWhitelist)
+
+	proxyTLSClientConfig := &tls.Config{InsecureSkipVerify: true}
+
+	proxyTransport := utilnet.SetTransportDefaults(&http.Transport{
+		DialContext:     proxyDialerFn,
+		TLSClientConfig: proxyTLSClientConfig,
+	})
+	return proxyTransport, nil
+}
+
+func createWhitelistDialer(whitelist kubeoptions.IPNetSlice) func(context.Context, string, string) (net.Conn, error) {
+	return func(ctx context.Context, network, addr string) (net.Conn, error) {
+		start := time.Now()
+		id := mathrand.Int63() // So you can match begins/ends in the log.
+		glog.Infof("[%x: %v] Dialing...", id, addr)
+		defer func() {
+			glog.Infof("[%x: %v] Dialed in %v.", id, addr, time.Since(start))
+		}()
+
+		if !whitelist.Contains(strings.Split(addr, ":")[0]) {
+			return nil, errors.New("Address is not allowed")
+		}
+		dialer := &net.Dialer{}
+		return dialer.DialContext(ctx, network, addr)
+	}
+}
diff --git a/cmd/kube-apiserver/app/options/BUILD b/cmd/kube-apiserver/app/options/BUILD
index 857701f7903..b3d7ee97084 100644
--- a/cmd/kube-apiserver/app/options/BUILD
+++ b/cmd/kube-apiserver/app/options/BUILD
@@ -11,6 +11,7 @@ go_library(
     srcs = [
         "options.go",
         "validation.go",
+        "whitelist.go",
     ],
     importpath = "k8s.io/kubernetes/cmd/kube-apiserver/app/options",
     deps = [
diff --git a/cmd/kube-apiserver/app/options/options.go b/cmd/kube-apiserver/app/options/options.go
index 2e5276d4bc7..96b24bf3592 100644
--- a/cmd/kube-apiserver/app/options/options.go
+++ b/cmd/kube-apiserver/app/options/options.go
@@ -57,6 +57,7 @@ type ServerRunOptions struct {
 	KubeletConfig             kubeletclient.KubeletClientConfig
 	KubernetesServiceNodePort int
 	MaxConnectionBytesPerSec  int64
+	ProxyCIDRWhitelist        kubeoptions.IPNetSlice
 	ServiceClusterIPRange     net.IPNet // TODO: make this a list
 	ServiceNodePortRange      utilnet.PortRange
 	SSHKeyfile                string
@@ -77,17 +78,17 @@ type ServerRunOptions struct {
 func NewServerRunOptions() *ServerRunOptions {
 	s := ServerRunOptions{
 		GenericServerRunOptions: genericoptions.NewServerRunOptions(),
-		Etcd:                 genericoptions.NewEtcdOptions(storagebackend.NewDefaultConfig(kubeoptions.DefaultEtcdPathPrefix, nil)),
-		SecureServing:        kubeoptions.NewSecureServingOptions(),
-		InsecureServing:      kubeoptions.NewInsecureServingOptions(),
-		Audit:                genericoptions.NewAuditOptions(),
-		Features:             genericoptions.NewFeatureOptions(),
-		Admission:            kubeoptions.NewAdmissionOptions(),
-		Authentication:       kubeoptions.NewBuiltInAuthenticationOptions().WithAll(),
-		Authorization:        kubeoptions.NewBuiltInAuthorizationOptions(),
-		CloudProvider:        kubeoptions.NewCloudProviderOptions(),
-		StorageSerialization: kubeoptions.NewStorageSerializationOptions(),
-		APIEnablement:        genericoptions.NewAPIEnablementOptions(),
+		Etcd:                    genericoptions.NewEtcdOptions(storagebackend.NewDefaultConfig(kubeoptions.DefaultEtcdPathPrefix, nil)),
+		SecureServing:           kubeoptions.NewSecureServingOptions(),
+		InsecureServing:         kubeoptions.NewInsecureServingOptions(),
+		Audit:                   genericoptions.NewAuditOptions(),
+		Features:                genericoptions.NewFeatureOptions(),
+		Admission:               kubeoptions.NewAdmissionOptions(),
+		Authentication:          kubeoptions.NewBuiltInAuthenticationOptions().WithAll(),
+		Authorization:           kubeoptions.NewBuiltInAuthorizationOptions(),
+		CloudProvider:           kubeoptions.NewCloudProviderOptions(),
+		StorageSerialization:    kubeoptions.NewStorageSerializationOptions(),
+		APIEnablement:           genericoptions.NewAPIEnablementOptions(),
 
 		EnableLogsHandler:      true,
 		EventTTL:               1 * time.Hour,
@@ -114,6 +115,7 @@ func NewServerRunOptions() *ServerRunOptions {
 		ServiceNodePortRange: kubeoptions.DefaultServiceNodePortRange,
 	}
 	s.ServiceClusterIPRange = kubeoptions.DefaultServiceIPCIDR
+	s.ProxyCIDRWhitelist = kubeoptions.DefaultProxyCIDRWhitelist
 
 	// Overwrite the default for storage data format.
 	s.Etcd.DefaultStorageMediaType = "application/vnd.kubernetes.protobuf"
@@ -181,6 +183,9 @@ func (s *ServerRunOptions) Flags() (fss apiserverflag.NamedFlagSets) {
 		"A CIDR notation IP range from which to assign service cluster IPs. This must not "+
 		"overlap with any IP ranges assigned to nodes for pods.")
 
+	fs.Var(&s.ProxyCIDRWhitelist, "proxy-cidr-whitelist", ""+
+		"A comma-separated list of CIDR IP ranges which the API server can communicate with.")
+
 	fs.Var(&s.ServiceNodePortRange, "service-node-port-range", ""+
 		"A port range to reserve for services with NodePort visibility. "+
 		"Example: '30000-32767'. Inclusive at both ends of the range.")
diff --git a/cmd/kube-apiserver/app/options/validation.go b/cmd/kube-apiserver/app/options/validation.go
index f1295756621..2e93d3fcc97 100644
--- a/cmd/kube-apiserver/app/options/validation.go
+++ b/cmd/kube-apiserver/app/options/validation.go
@@ -24,6 +24,18 @@ import (
 	"k8s.io/kubernetes/pkg/api/legacyscheme"
 )
 
+func validateProxyCIDRWhitelist(options *ServerRunOptions) []error {
+	errors := []error{}
+
+	// if its empty, don't add any IPs to the list
+	for _, cidr := range options.ProxyCIDRWhitelist {
+		if cidr.IP == nil {
+			errors = append(errors, fmt.Errorf("invalid --proxy-cidr-whitelist specified"))
+		}
+	}
+	return errors
+}
+
 // TODO: Longer term we should read this from some config store, rather than a flag.
 func validateClusterIPFlags(options *ServerRunOptions) []error {
 	errors := []error{}
@@ -55,6 +67,9 @@ func (s *ServerRunOptions) Validate() []error {
 	if errs := s.Etcd.Validate(); len(errs) > 0 {
 		errors = append(errors, errs...)
 	}
+	if errs := validateProxyCIDRWhitelist(s); len(errs) > 0 {
+		errors = append(errors, errs...)
+	}
 	if errs := validateClusterIPFlags(s); len(errs) > 0 {
 		errors = append(errors, errs...)
 	}
diff --git a/cmd/kube-apiserver/app/options/whitelist.go b/cmd/kube-apiserver/app/options/whitelist.go
new file mode 100644
index 00000000000..6accbd0ab2c
--- /dev/null
+++ b/cmd/kube-apiserver/app/options/whitelist.go
@@ -0,0 +1,9 @@
+package options
+
+import (
+	kubeoptions "k8s.io/kubernetes/pkg/kubeapiserver/options"
+)
+
+var (
+	ProxyCIDRWhitelist kubeoptions.IPNetSlice = kubeoptions.DefaultProxyCIDRWhitelist
+)
diff --git a/cmd/kube-apiserver/app/server.go b/cmd/kube-apiserver/app/server.go
index 455b5a6e8b4..76bb60bd23e 100644
--- a/cmd/kube-apiserver/app/server.go
+++ b/cmd/kube-apiserver/app/server.go
@@ -166,6 +166,12 @@ func CreateServerChain(completedOptions completedServerRunOptions, stopCh <-chan
 		return nil, err
 	}
 
+	// This will likely break node dialer, any good ideas for how to mitigate that?
+	proxyTransport, err = CreateOutboundDialer(completedOptions)
+	if err != nil {
+		return nil, err
+	}
+
 	kubeAPIServerConfig, insecureServingInfo, serviceResolver, pluginInitializer, admissionPostStartHook, err := CreateKubeAPIServerConfig(completedOptions, nodeTunneler, proxyTransport)
 	if err != nil {
 		return nil, err
@@ -664,6 +670,7 @@ func Complete(s *options.ServerRunOptions) (completedServerRunOptions, error) {
 		return options, fmt.Errorf("error determining service IP ranges: %v", err)
 	}
 	s.ServiceClusterIPRange = serviceIPRange
+
 	if err := s.SecureServing.MaybeDefaultWithSelfSignedCerts(s.GenericServerRunOptions.AdvertiseAddress.String(), []string{"kubernetes.default.svc", "kubernetes.default", "kubernetes"}, []net.IP{apiServerServiceIP}); err != nil {
 		return options, fmt.Errorf("error creating self-signed certificates: %v", err)
 	}
diff --git a/pkg/kubeapiserver/options/BUILD b/pkg/kubeapiserver/options/BUILD
index 8739863a8d8..0b46748fc78 100644
--- a/pkg/kubeapiserver/options/BUILD
+++ b/pkg/kubeapiserver/options/BUILD
@@ -13,6 +13,7 @@ go_library(
         "authentication.go",
         "authorization.go",
         "cloudprovider.go",
+        "ipnetslice.go",
         "options.go",
         "plugins.go",
         "serving.go",
@@ -92,6 +93,7 @@ go_test(
         "admission_test.go",
         "authentication_test.go",
         "authorization_test.go",
+        "ipnetslice_test.go",
         "storage_versions_test.go",
     ],
     embed = [":go_default_library"],
diff --git a/pkg/kubeapiserver/options/ipnetslice.go b/pkg/kubeapiserver/options/ipnetslice.go
new file mode 100644
index 00000000000..c38fa6cd3ce
--- /dev/null
+++ b/pkg/kubeapiserver/options/ipnetslice.go
@@ -0,0 +1,93 @@
+/*
+This file is here because flags seemed to mostly be in staging/k8s.io/apiserver. Is there a better place for this?
+*/
+package options
+
+import (
+	"context"
+	"encoding/csv"
+	"net"
+	"strings"
+)
+
+// IPNetSlice is a flag for comma-separated slices of CIDR addresses
+type IPNetSlice []net.IPNet
+
+// String satisfies pflag.Value
+func (netSlice IPNetSlice) String() string {
+	netStrings := []string{}
+	for _, n := range netSlice {
+		netStrings = append(netStrings, n.String())
+	}
+	return strings.Join(netStrings, ",")
+}
+
+// Set satisfies pflag.Value
+func (netSlice *IPNetSlice) Set(value string) error {
+	cidrStrings, err := readAsCSV(value)
+	if err != nil {
+		return err
+	}
+	for _, v := range cidrStrings {
+		_, n, err := net.ParseCIDR(strings.TrimSpace(v))
+		if err != nil {
+			return err
+		}
+		*netSlice = append(*netSlice, *n)
+	}
+	return nil
+}
+
+func readAsCSV(val string) ([]string, error) {
+	if val == "" {
+		return []string{}, nil
+	}
+	stringReader := strings.NewReader(val)
+	csvReader := csv.NewReader(stringReader)
+	return csvReader.Read()
+}
+
+// Type satisfies plfag.Value
+func (netSlice *IPNetSlice) Type() string {
+	return "[]net.IPNet"
+}
+
+// ContainsHost checks if all the IPs for a given hostname are in the whitelist
+func (netSlice *IPNetSlice) ContainsHost(ctx context.Context, host string) (bool, error) {
+	r := net.Resolver{}
+	resp, err := r.LookupIPAddr(ctx, host)
+	if err != nil {
+		return false, err
+	}
+	for _, host := range resp {
+		// reject if any of the IPs for a hostname are not in the whitelist
+		if !netSlice.Contains(host.String()) {
+			return false, nil
+		}
+	}
+	return true, nil
+}
+
+// Contains checks if a given IP is in the whitelist
+func (netSlice *IPNetSlice) Contains(ip string) bool {
+	// if there are no whitelists, everything is allowed
+	if len(*netSlice) == 0 {
+		return true
+	}
+	netIP := net.ParseIP(ip)
+	for _, cidr := range *netSlice {
+		if cidr.Contains(netIP) {
+			return true
+		}
+	}
+	return false
+}
+
+// NewIPNetSlice creates a new IPNetSlice for a given list of networks
+func NewIPNetSlice(nets ...string) IPNetSlice {
+	netSlice := &IPNetSlice{}
+	for _, network := range nets {
+		netSlice.Set(network)
+	}
+	return *netSlice
+}
diff --git a/pkg/kubeapiserver/options/ipnetslice_test.go b/pkg/kubeapiserver/options/ipnetslice_test.go
new file mode 100644
index 00000000000..f901214d692
--- /dev/null
+++ b/pkg/kubeapiserver/options/ipnetslice_test.go
@@ -0,0 +1,36 @@
+package options
+
+import (
+	"testing"
+)
+
+func TestIPNetSliceContains(t *testing.T) {
+	cases := []struct {
+		inputNets []string
+		inputIP   string
+		want      bool
+	}{
+		{
+			[]string{"192.168.0.1/24"},
+			"192.168.0.22",
+			true,
+		},
+		{
+			[]string{"192.168.0.1/24"},
+			"192.168.1.22",
+			false,
+		},
+		{
+			[]string{"192.168.0.1/24", "10.0.0.1/8"},
+			"10.0.100.1",
+			true,
+		},
+	}
+
+	for _, c := range cases {
+		ns := NewIPNetSlice(c.inputNets...)
+		if ns.Contains(c.inputIP) != c.want {
+			t.Errorf("%v.Contains(%s) was wrong: got %t, expected %t", ns, c.inputIP, !c.want, c.want)
+		}
+	}
+}
diff --git a/pkg/kubeapiserver/options/options.go b/pkg/kubeapiserver/options/options.go
index f7e6eedaf71..3be9f0b0378 100644
--- a/pkg/kubeapiserver/options/options.go
+++ b/pkg/kubeapiserver/options/options.go
@@ -27,3 +27,5 @@ var DefaultServiceNodePortRange = utilnet.PortRange{Base: 30000, Size: 2768}
 
 // DefaultServiceIPCIDR is a CIDR notation of IP range from which to allocate service cluster IPs
 var DefaultServiceIPCIDR net.IPNet = net.IPNet{IP: net.ParseIP("10.0.0.0"), Mask: net.CIDRMask(24, 32)}
+
+var DefaultProxyCIDRWhitelist IPNetSlice = NewIPNetSlice()
diff --git a/pkg/registry/core/node/BUILD b/pkg/registry/core/node/BUILD
index 0819655b314..262c812859e 100644
--- a/pkg/registry/core/node/BUILD
+++ b/pkg/registry/core/node/BUILD
@@ -14,6 +14,7 @@ go_library(
     ],
     importpath = "k8s.io/kubernetes/pkg/registry/core/node",
     deps = [
+        "//cmd/kube-apiserver/app/options:go_default_library",
         "//pkg/api/legacyscheme:go_default_library",
         "//pkg/apis/core:go_default_library",
         "//pkg/apis/core/validation:go_default_library",
diff --git a/pkg/registry/core/node/strategy.go b/pkg/registry/core/node/strategy.go
index c180fc287b1..e99191b1e9a 100644
--- a/pkg/registry/core/node/strategy.go
+++ b/pkg/registry/core/node/strategy.go
@@ -35,6 +35,7 @@ import (
 	pkgstorage "k8s.io/apiserver/pkg/storage"
 	"k8s.io/apiserver/pkg/storage/names"
 	utilfeature "k8s.io/apiserver/pkg/util/feature"
+	kubeapiserveroptions "k8s.io/kubernetes/cmd/kube-apiserver/app/options"
 	"k8s.io/kubernetes/pkg/api/legacyscheme"
 	api "k8s.io/kubernetes/pkg/apis/core"
 	"k8s.io/kubernetes/pkg/apis/core/validation"
@@ -206,6 +207,19 @@ func ResourceLocation(getter ResourceGetter, connection client.ConnectionInfoGet
 		return nil, nil, err
 	}
 
+	// REVIEW NOTE:
+	// I didn't see a better way to plumb this down here. Feature gates are globals too, but I'd be happy to get the CIDRs here another way
+	included, err := kubeapiserveroptions.ProxyCIDRWhitelist.ContainsHost(
+		ctx,
+		info.Hostname,
+	)
+	if err != nil {
+		return nil, nil, err
+	}
+	if !included {
+		return nil, nil, errors.NewBadRequest("Address is not allowed")
+	}
+
 	// We check if we want to get a default Kubelet's transport. It happens if either:
 	// - no port is specified in request (Kubelet's port is default)
 	// - the requested port matches the kubelet port for this node
-- 
2.14.3 (Apple Git-98)

