From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Cenk Alti <alticen@amazon.com>
Date: Wed, 14 Sep 2022 18:13:30 -0400
Subject: [PATCH] --EKS-PRIVATE-- Optional maximum etcd page size on every list

---
 .../apiserver/pkg/server/options/etcd.go      |   3 +
 .../pkg/storage/etcd3/metrics/metrics.go      |  15 ++
 .../apiserver/pkg/storage/etcd3/store.go      |  55 ++++--
 .../apiserver/pkg/storage/etcd3/store_test.go | 173 +++++++++++++++++-
 .../pkg/storage/storagebackend/config.go      |   3 +-
 .../storage/storagebackend/factory/etcd3.go   |   3 +-
 .../pkg/storage/tests/cacher_test.go          |   4 +-
 7 files changed, 235 insertions(+), 21 deletions(-)

diff --git a/staging/src/k8s.io/apiserver/pkg/server/options/etcd.go b/staging/src/k8s.io/apiserver/pkg/server/options/etcd.go
index c43b06d8e93..be0301c1735 100644
--- a/staging/src/k8s.io/apiserver/pkg/server/options/etcd.go
+++ b/staging/src/k8s.io/apiserver/pkg/server/options/etcd.go
@@ -186,6 +186,9 @@ func (s *EtcdOptions) AddFlags(fs *pflag.FlagSet) {
 	fs.DurationVar(&s.StorageConfig.HealthcheckTimeout, "etcd-healthcheck-timeout", s.StorageConfig.HealthcheckTimeout,
 		"The timeout to use when checking etcd health.")
 
+	fs.Int64Var(&s.StorageConfig.MaximumPageSize, "maximum-page-size-for-etcd-lists", s.StorageConfig.MaximumPageSize,
+		"Maximum etcd page size for etcd lists. If zero, the limit is unbounded")
+
 	fs.DurationVar(&s.StorageConfig.ReadycheckTimeout, "etcd-readycheck-timeout", s.StorageConfig.ReadycheckTimeout,
 		"The timeout to use when checking etcd readiness")
 
diff --git a/staging/src/k8s.io/apiserver/pkg/storage/etcd3/metrics/metrics.go b/staging/src/k8s.io/apiserver/pkg/storage/etcd3/metrics/metrics.go
index 769cec77193..32a941ba1a0 100644
--- a/staging/src/k8s.io/apiserver/pkg/storage/etcd3/metrics/metrics.go
+++ b/staging/src/k8s.io/apiserver/pkg/storage/etcd3/metrics/metrics.go
@@ -112,6 +112,15 @@ var (
 		},
 		[]string{"resource"},
 	)
+	listStorageLatency = compbasemetrics.NewHistogramVec(
+		&compbasemetrics.HistogramOpts{
+			Name:           "apiserver_storage_list_duration_seconds",
+			Help:           "Duration of objects returned for a LIST request from storage",
+			Buckets:        []float64{0.005, 0.025, 0.1, 0.25, 0.5, 1.0, 2.0, 4.0, 15.0, 30.0, 60.0},
+			StabilityLevel: compbasemetrics.ALPHA,
+		},
+		[]string{"resource"},
+	)
 )
 
 var registerMetrics sync.Once
@@ -129,6 +138,7 @@ func Register() {
 		legacyregistry.MustRegister(listStorageNumFetched)
 		legacyregistry.MustRegister(listStorageNumSelectorEvals)
 		legacyregistry.MustRegister(listStorageNumReturned)
+		legacyregistry.MustRegister(listStorageLatency)
 	})
 }
 
@@ -142,6 +152,11 @@ func RecordEtcdRequestLatency(verb, resource string, startTime time.Time) {
 	etcdRequestLatency.WithLabelValues(verb, resource).Observe(sinceInSeconds(startTime))
 }
 
+// RecordListStorageLatency sets the "apiserver_storage_list_duration_seconds" metrics.
+func RecordListStorageLatency(resource string, startTime time.Time) {
+	listStorageLatency.WithLabelValues(resource).Observe(sinceInSeconds(startTime))
+}
+
 // RecordEtcdBookmark updates the etcd_bookmark_counts metric.
 func RecordEtcdBookmark(resource string) {
 	etcdBookmarkCounts.WithLabelValues(resource).Inc()
diff --git a/staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go b/staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go
index b2e4c674687..2946fe0bdaf 100644
--- a/staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go
+++ b/staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go
@@ -80,9 +80,24 @@ type store struct {
 	groupResourceString string
 	watcher             *watcher
 	pagingEnabled       bool
+	maxPageSize         int64
 	leaseManager        *leaseManager
 }
 
+// PagingConfig groups the parameter related with paging inside GetList calls.
+// The main reason for paging is to protect etcd from returning unlimited list of items.
+// Because etcd buffers all of the response in memory before returning it to the client,
+// there is a possiblity of using too much memory and get killed by OOM killer.
+type PagingConfig struct {
+	// PagingEnabled enables/disables paging logic.
+	// If paging is disabled, etcd will return all items in the query.
+	PagingEnabled bool
+
+	// MaximumPageSize is a maximum page limit used when fetching objects from etcd.
+	// It has no effect if `PagingEnabled` is false.
+	MaximumPageSize int64
+}
+
 type objState struct {
 	obj   runtime.Object
 	meta  *storage.ResponseMeta
@@ -92,11 +107,11 @@ type objState struct {
 }
 
 // New returns an etcd3 implementation of storage.Interface.
-func New(c *clientv3.Client, codec runtime.Codec, newFunc func() runtime.Object, prefix string, groupResource schema.GroupResource, transformer value.Transformer, pagingEnabled bool, leaseManagerConfig LeaseManagerConfig) storage.Interface {
-	return newStore(c, codec, newFunc, prefix, groupResource, transformer, pagingEnabled, leaseManagerConfig)
+func New(c *clientv3.Client, codec runtime.Codec, newFunc func() runtime.Object, prefix string, groupResource schema.GroupResource, transformer value.Transformer, pagingConfig PagingConfig, leaseManagerConfig LeaseManagerConfig) storage.Interface {
+	return newStore(c, codec, newFunc, prefix, groupResource, transformer, pagingConfig, leaseManagerConfig)
 }
 
-func newStore(c *clientv3.Client, codec runtime.Codec, newFunc func() runtime.Object, prefix string, groupResource schema.GroupResource, transformer value.Transformer, pagingEnabled bool, leaseManagerConfig LeaseManagerConfig) *store {
+func newStore(c *clientv3.Client, codec runtime.Codec, newFunc func() runtime.Object, prefix string, groupResource schema.GroupResource, transformer value.Transformer, pagingConfig PagingConfig, leaseManagerConfig LeaseManagerConfig) *store {
 	versioner := storage.APIObjectVersioner{}
 	// for compatibility with etcd2 impl.
 	// no-op for default prefix of '/registry'.
@@ -111,13 +126,17 @@ func newStore(c *clientv3.Client, codec runtime.Codec, newFunc func() runtime.Ob
 		codec:               codec,
 		versioner:           versioner,
 		transformer:         transformer,
-		pagingEnabled:       pagingEnabled,
+		pagingEnabled:       pagingConfig.PagingEnabled,
+		maxPageSize:         pagingConfig.MaximumPageSize,
 		pathPrefix:          pathPrefix,
 		groupResource:       groupResource,
 		groupResourceString: groupResource.String(),
 		watcher:             newWatcher(c, codec, newFunc, versioner, transformer),
 		leaseManager:        newDefaultLeaseManager(c, leaseManagerConfig),
 	}
+	if result.pagingEnabled && result.maxPageSize <= 0 {
+		result.maxPageSize = maxLimit
+	}
 	return result
 }
 
@@ -581,7 +600,11 @@ func (s *store) GetList(ctx context.Context, key string, opts storage.ListOption
 	limit := pred.Limit
 	var paging bool
 	options := make([]clientv3.OpOption, 0, 4)
-	if s.pagingEnabled && pred.Limit > 0 {
+	if s.pagingEnabled {
+		// Put a default limit if no limit specified and cap it at max value.
+		if limit <= 0 || limit > s.maxPageSize {
+			limit = s.maxPageSize
+		}
 		paging = true
 		options = append(options, clientv3.WithLimit(limit))
 		limitOption = &options[len(options)-1]
@@ -622,7 +645,7 @@ func (s *store) GetList(ctx context.Context, key string, opts storage.ListOption
 			withRev = continueRV
 			returnedRV = continueRV
 		}
-	case recursive && s.pagingEnabled && pred.Limit > 0:
+	case recursive && s.pagingEnabled:
 		if fromRV != nil {
 			switch match {
 			case metav1.ResourceVersionMatchNotOlderThan:
@@ -632,7 +655,7 @@ func (s *store) GetList(ctx context.Context, key string, opts storage.ListOption
 				returnedRV = int64(*fromRV)
 				withRev = returnedRV
 			case "": // legacy case
-				if *fromRV > 0 {
+				if *fromRV > 0 && pred.Limit > 0 {
 					returnedRV = int64(*fromRV)
 					withRev = returnedRV
 				}
@@ -672,9 +695,16 @@ func (s *store) GetList(ctx context.Context, key string, opts storage.ListOption
 	var getResp *clientv3.GetResponse
 	var numFetched int
 	var numEvald int
+	var pages int
 	// Because these metrics are for understanding the costs of handling LIST requests,
 	// get them recorded even in error cases.
+	start := time.Now()
 	defer func() {
+		if err == nil {
+			// quantify the list from storage latency
+			metrics.RecordListStorageLatency(s.groupResourceString, start)
+		}
+		trace.Step("fetched all pages from etcd", utiltrace.Field{Key: "page-count", Value: pages})
 		numReturn := v.Len()
 		metrics.RecordStorageListMetrics(s.groupResourceString, numFetched, numEvald, numReturn)
 	}()
@@ -690,6 +720,7 @@ func (s *store) GetList(ctx context.Context, key string, opts storage.ListOption
 			return interpretListError(err, len(pred.Continue) > 0, continueKey, keyPrefix)
 		}
 		numFetched += len(getResp.Kvs)
+		pages++
 		if err = s.validateMinimumResourceVersion(resourceVersion, uint64(getResp.Header.Revision)); err != nil {
 			return err
 		}
@@ -709,7 +740,7 @@ func (s *store) GetList(ctx context.Context, key string, opts storage.ListOption
 
 		// take items from the response until the bucket is full, filtering as we go
 		for i, kv := range getResp.Kvs {
-			if paging && int64(v.Len()) >= pred.Limit {
+			if limitOption != nil && pred.Limit > 0 && int64(v.Len()) >= pred.Limit {
 				hasMore = true
 				break
 			}
@@ -739,16 +770,16 @@ func (s *store) GetList(ctx context.Context, key string, opts storage.ListOption
 			break
 		}
 		// we're paging but we have filled our bucket
-		if int64(v.Len()) >= pred.Limit {
+		if limitOption != nil && pred.Limit > 0 && int64(v.Len()) >= pred.Limit {
 			break
 		}
 
-		if limit < maxLimit {
+		if limit < s.maxPageSize {
 			// We got incomplete result due to field/label selector dropping the object.
 			// Double page size to reduce total number of calls to etcd.
 			limit *= 2
-			if limit > maxLimit {
-				limit = maxLimit
+			if limit > s.maxPageSize {
+				limit = s.maxPageSize
 			}
 			*limitOption = clientv3.WithLimit(limit)
 		}
diff --git a/staging/src/k8s.io/apiserver/pkg/storage/etcd3/store_test.go b/staging/src/k8s.io/apiserver/pkg/storage/etcd3/store_test.go
index 2f0dfe6e588..519c416423b 100644
--- a/staging/src/k8s.io/apiserver/pkg/storage/etcd3/store_test.go
+++ b/staging/src/k8s.io/apiserver/pkg/storage/etcd3/store_test.go
@@ -53,8 +53,11 @@ import (
 var scheme = runtime.NewScheme()
 var codecs = serializer.NewCodecFactory(scheme)
 
-const defaultTestPrefix = "test!"
-const basePath = "/keybase"
+const (
+	basePath                = "/keybase"
+	defaultTestPrefix       = "test!"
+	defaultListEtcdMaxLimit = 500
+)
 
 func init() {
 	metav1.AddToGroupVersion(scheme, metav1.SchemeGroupVersion)
@@ -738,6 +741,164 @@ func TestListPaginationRareObject(t *testing.T) {
 	recorder.resetReads()
 }
 
+func TestListPaginationWithEnforcedLimit(t *testing.T) {
+	client := testserver.RunEtcd(t, nil)
+	transformer := newTestTransformer()
+	recorder := &clientRecorder{KV: client.KV}
+	client.KV = recorder
+
+	ctx, store, _ := testSetup(t, withClient(client), withTransformer(transformer))
+
+	// write pods
+	podCount := 2000
+	var pods []*example.Pod
+	for i := 0; i < podCount; i++ {
+		key := fmt.Sprintf("%s/one-level/pod-%04d", basePath, i)
+		obj := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf("pod-%04d", i)}}
+		storedObj := &example.Pod{}
+		err := store.Create(ctx, key, obj, storedObj, 0)
+		if err != nil {
+			t.Fatalf("Set failed: %v", err)
+		}
+		pods = append(pods, storedObj)
+	}
+
+	// user list requests with 100 limit + latest resource version
+	options := storage.ListOptions{
+		ResourceVersion: "0",
+		Predicate: storage.SelectionPredicate{
+			Label: labels.Everything(),
+			GetAttrs: func(obj runtime.Object) (labels.Set, fields.Set, error) {
+				pod := obj.(*example.Pod)
+				return nil, fields.Set{"metadata.name": pod.Name}, nil
+			},
+		},
+		Recursive: true,
+	}
+
+	testCases := []struct {
+		// are we selecting everything or one item?
+		setFieldSelector bool
+		// predicate setLimit
+		setLimit int64
+		// expected number of total items from GetList
+		expectItems int
+		// expected number of transformer reads
+		expectTransformerReads uint64
+		// expected number of calls to etcd
+		expectPages int
+		// expected continuation token in GetList response
+		expectContinue bool
+	}{
+		{
+			setFieldSelector:       false,
+			setLimit:               0, // no limit is set, we want all items
+			expectItems:            2000,
+			expectTransformerReads: 2000,
+			expectPages:            4,
+			expectContinue:         false,
+		},
+		{
+			setFieldSelector:       false,
+			setLimit:               50, // limit < maxLimit
+			expectItems:            50,
+			expectTransformerReads: 50,
+			expectPages:            1,
+			expectContinue:         true,
+		},
+		{
+			setFieldSelector:       false,
+			setLimit:               500, // limit = maxLimit
+			expectItems:            500,
+			expectTransformerReads: 500,
+			expectPages:            1,
+			expectContinue:         true,
+		},
+		{
+			setFieldSelector:       false,
+			setLimit:               1000, // limit > maxLimit
+			expectItems:            1000,
+			expectTransformerReads: 1000,
+			expectPages:            2,
+			expectContinue:         true,
+		},
+		{
+			setFieldSelector:       true,
+			setLimit:               0,
+			expectItems:            1,
+			expectTransformerReads: 2000,
+			expectPages:            4,
+			expectContinue:         false,
+		},
+		{
+			setFieldSelector:       true,
+			setLimit:               1,
+			expectItems:            1,
+			expectTransformerReads: 1000,
+			expectPages:            10,
+			expectContinue:         true,
+		},
+		{
+			setFieldSelector:       true,
+			setLimit:               50,
+			expectItems:            1,
+			expectTransformerReads: 2000,
+			expectPages:            7,
+			expectContinue:         false,
+		},
+		{
+			setFieldSelector:       true,
+			setLimit:               500,
+			expectItems:            1,
+			expectTransformerReads: 2000,
+			expectPages:            4,
+			expectContinue:         false,
+		},
+		{
+			setFieldSelector:       true,
+			setLimit:               1000,
+			expectItems:            1,
+			expectTransformerReads: 2000,
+			expectPages:            4,
+			expectContinue:         false,
+		},
+	}
+	for i, tc := range testCases {
+		t.Logf("--- Running test case #%d:\n\tsetFieldSelector: %v\n\tsetLimit: %d\n\texpectItems: %d\n\texpectTransformerReads: %d\n\texpectPages: %d\n\texpectContinue: %v", i, tc.setFieldSelector, tc.setLimit, tc.expectItems, tc.expectTransformerReads, tc.expectPages, tc.expectContinue)
+
+		options.Predicate.Limit = tc.setLimit
+		if tc.setFieldSelector {
+			options.Predicate.Field = fields.OneTermEqualSelector("metadata.name", "pod-0999")
+		} else {
+			options.Predicate.Field = fields.Everything()
+		}
+
+		out := &example.PodList{}
+		if err := store.GetList(ctx, basePath, options, out); err != nil {
+			t.Fatalf("Unable to get initial list: %v", err)
+		}
+		if tc.expectContinue != (len(out.Continue) != 0) {
+			t.Errorf("Unexpected continuation token")
+		}
+		if len(out.Items) != tc.expectItems {
+			t.Fatalf("expect %d items, but got %d", tc.expectItems, len(out.Items))
+		}
+		if tc.setFieldSelector {
+			if !reflect.DeepEqual(&out.Items[0], pods[999]) {
+				t.Fatalf("Unexpected first page: %#v", out.Items)
+			}
+		}
+		if transformer.reads != tc.expectTransformerReads {
+			t.Errorf("unexpected reads: %d", transformer.reads)
+		}
+		if int(recorder.reads) != tc.expectPages {
+			t.Errorf("expect reads: %d, but got %d", tc.expectPages, recorder.reads)
+		}
+		transformer.resetReads()
+		recorder.resetReads()
+	}
+}
+
 type clientRecorder struct {
 	reads uint64
 	clientv3.KV
@@ -1038,7 +1199,7 @@ type setupOptions struct {
 	prefix        string
 	groupResource schema.GroupResource
 	transformer   value.Transformer
-	pagingEnabled bool
+	pagingConfig  PagingConfig
 	leaseConfig   LeaseManagerConfig
 }
 
@@ -1074,7 +1235,7 @@ func withPrefix(prefix string) setupOption {
 
 func withoutPaging() setupOption {
 	return func(options *setupOptions) {
-		options.pagingEnabled = false
+		options.pagingConfig.PagingEnabled = false
 	}
 }
 
@@ -1099,7 +1260,7 @@ func withDefaults(options *setupOptions) {
 	options.prefix = ""
 	options.groupResource = schema.GroupResource{Resource: "pods"}
 	options.transformer = newTestTransformer()
-	options.pagingEnabled = true
+	options.pagingConfig = PagingConfig{PagingEnabled: true, MaximumPageSize: defaultListEtcdMaxLimit}
 	options.leaseConfig = newTestLeaseManagerConfig()
 }
 
@@ -1119,7 +1280,7 @@ func testSetup(t *testing.T, opts ...setupOption) (context.Context, *store, *cli
 		setupOpts.prefix,
 		setupOpts.groupResource,
 		setupOpts.transformer,
-		setupOpts.pagingEnabled,
+		setupOpts.pagingConfig,
 		setupOpts.leaseConfig,
 	)
 	ctx := context.Background()
diff --git a/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/config.go b/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/config.go
index 694ca749a1c..4bf20243428 100644
--- a/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/config.go
+++ b/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/config.go
@@ -67,7 +67,8 @@ type Config struct {
 	// supported). This is generally configured by feature gating, or by a specific
 	// resource type not wishing to allow paging, and is not intended for end users to
 	// set.
-	Paging bool
+	Paging          bool
+	MaximumPageSize int64
 
 	Codec runtime.Codec
 	// EncodeVersioner is the same groupVersioner used to build the
diff --git a/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/etcd3.go b/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/etcd3.go
index 76b5fcffb2e..b6795abd24d 100644
--- a/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/etcd3.go
+++ b/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/etcd3.go
@@ -364,7 +364,8 @@ func newETCD3Storage(c storagebackend.ConfigForResource, newFunc func() runtime.
 	if transformer == nil {
 		transformer = value.IdentityTransformer
 	}
-	return etcd3.New(client, c.Codec, newFunc, c.Prefix, c.GroupResource, transformer, c.Paging, c.LeaseManagerConfig), destroyFunc, nil
+	pagingConfig := etcd3.PagingConfig{PagingEnabled: c.Paging, MaximumPageSize: c.MaximumPageSize}
+	return etcd3.New(client, c.Codec, newFunc, c.Prefix, c.GroupResource, transformer, pagingConfig, c.LeaseManagerConfig), destroyFunc, nil
 }
 
 // startDBSizeMonitorPerEndpoint starts a loop to monitor etcd database size and update the
diff --git a/staging/src/k8s.io/apiserver/pkg/storage/tests/cacher_test.go b/staging/src/k8s.io/apiserver/pkg/storage/tests/cacher_test.go
index 0b036c36809..a68fc906155 100644
--- a/staging/src/k8s.io/apiserver/pkg/storage/tests/cacher_test.go
+++ b/staging/src/k8s.io/apiserver/pkg/storage/tests/cacher_test.go
@@ -63,6 +63,7 @@ var (
 const (
 	// watchCacheDefaultCapacity syncs watch cache defaultLowerBoundCapacity.
 	watchCacheDefaultCapacity = 100
+	defaultListEtcdMaxLimit   = 500
 )
 
 func init() {
@@ -107,7 +108,8 @@ func newPodList() runtime.Object { return &example.PodList{} }
 
 func newEtcdTestStorage(t *testing.T, prefix string) (*etcd3testing.EtcdTestServer, storage.Interface) {
 	server, _ := etcd3testing.NewUnsecuredEtcd3TestClientServer(t)
-	storage := etcd3.New(server.V3Client, apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion), newPod, prefix, schema.GroupResource{Resource: "pods"}, value.IdentityTransformer, true, etcd3.NewDefaultLeaseManagerConfig())
+	pagingConfig := etcd3.PagingConfig{PagingEnabled: true, MaximumPageSize: defaultListEtcdMaxLimit}
+	storage := etcd3.New(server.V3Client, apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion), newPod, prefix, schema.GroupResource{Resource: "pods"}, value.IdentityTransformer, pagingConfig, etcd3.NewDefaultLeaseManagerConfig())
 	return server, storage
 }
 
