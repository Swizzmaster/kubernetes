From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Micah Hausler <mhausler@amazon.com>
Date: Thu, 17 Jan 2019 15:41:00 -0800
Subject: [PATCH] --EKS-PRIVATE-- Added support for external JWT signing and
 verifying

ref. https://github.com/micahhausler/kubernetes/commit/147f45449d6d750c848751eb7d17aba4a9b571be

1.22: Support for multiple issuers was added, so that migration is
possible from 1 issuer to another, so this patch needed to be rebased.
---
 cmd/kube-apiserver/app/options/validation.go  |  26 ++
 cmd/kube-apiserver/app/server.go              |  20 ++
 ...ate-generated-externalsigner-dockerized.sh |  63 ++++
 hack/update-generated-externalsigner.sh       |  29 ++
 hack/verify-generated-externalsigner.sh       |  45 +++
 pkg/features/kube_features.go                 |   7 +
 pkg/kubeapiserver/authenticator/config.go     |  15 +-
 pkg/kubeapiserver/options/authentication.go   |   5 +
 .../externalsigner/v1alpha1/service.pb.go     | 317 ++++++++++++++++++
 .../externalsigner/v1alpha1/service.proto     |  40 +++
 pkg/serviceaccount/jwt.go                     |  18 +-
 pkg/serviceaccount/jwt_external.go            | 187 +++++++++++
 pkg/serviceaccount/jwt_external_test.go       | 128 +++++++
 pkg/serviceaccount/jwt_test.go                | 171 +++++++---
 staging/src/k8s.io/client-go/util/cert/pem.go |   7 +-
 .../go-jose.v2/cryptosigner/cryptosigner.go   | 138 ++++++++
 vendor/modules.txt                            |   1 +
 17 files changed, 1153 insertions(+), 64 deletions(-)
 create mode 100755 hack/update-generated-externalsigner-dockerized.sh
 create mode 100755 hack/update-generated-externalsigner.sh
 create mode 100755 hack/verify-generated-externalsigner.sh
 create mode 100644 pkg/serviceaccount/externalsigner/v1alpha1/service.pb.go
 create mode 100644 pkg/serviceaccount/externalsigner/v1alpha1/service.proto
 create mode 100644 pkg/serviceaccount/jwt_external.go
 create mode 100644 pkg/serviceaccount/jwt_external_test.go
 create mode 100644 vendor/gopkg.in/square/go-jose.v2/cryptosigner/cryptosigner.go

diff --git a/cmd/kube-apiserver/app/options/validation.go b/cmd/kube-apiserver/app/options/validation.go
index 4bf416d6961..566077609ac 100644
--- a/cmd/kube-apiserver/app/options/validation.go
+++ b/cmd/kube-apiserver/app/options/validation.go
@@ -19,6 +19,7 @@ package options
 import (
 	"errors"
 	"fmt"
+	"k8s.io/kubernetes/pkg/features"
 	"net"
 	"strings"
 
@@ -153,6 +154,24 @@ func validateAPIPriorityAndFairness(options *ServerRunOptions) []error {
 	return nil
 }
 
+func validateExternalKeyServer(options *ServerRunOptions) []error {
+	var errs []error
+
+	enableAttempted := options.Authentication.ServiceAccounts.KeyServiceURL != ""
+	requiredTokenFlagsSet := len(options.Authentication.ServiceAccounts.Issuers) != 0
+
+	if enableAttempted && !utilfeature.DefaultFeatureGate.Enabled(features.ExternalKeyService) {
+		errs = append(errs, errors.New("the ExternalKeyService feature is not enabled but --key-service-url flag was passed"))
+	}
+
+	// TODO: @micahhausler validate url format of --key-service-url
+
+	if enableAttempted && !requiredTokenFlagsSet {
+		errs = append(errs, errors.New("the --key-service-url flag requires --service-account-issuer"))
+	}
+	return errs
+}
+
 func validateAPIServerIdentity(options *ServerRunOptions) []error {
 	var errs []error
 	if options.IdentityLeaseDurationSeconds <= 0 {
@@ -161,6 +180,13 @@ func validateAPIServerIdentity(options *ServerRunOptions) []error {
 	if options.IdentityLeaseRenewIntervalSeconds <= 0 {
 		errs = append(errs, fmt.Errorf("--identity-lease-renew-interval-seconds should be a positive number, but value '%d' provided", options.IdentityLeaseRenewIntervalSeconds))
 	}
+
+	if utilfeature.DefaultFeatureGate.Enabled(features.ExternalKeyService) {
+		errs = append(errs, validateExternalKeyServer(options)...)
+	} else {
+		errs = append(errs, validateTokenRequest(options)...)
+	}
+
 	return errs
 }
 
diff --git a/cmd/kube-apiserver/app/server.go b/cmd/kube-apiserver/app/server.go
index e265f03c8d9..84c10c024ef 100644
--- a/cmd/kube-apiserver/app/server.go
+++ b/cmd/kube-apiserver/app/server.go
@@ -605,7 +605,27 @@ func Complete(s *options.ServerRunOptions) (completedServerRunOptions, error) {
 		if err != nil {
 			return options, fmt.Errorf("failed to build token generator: %v", err)
 		}
+
+		s.ServiceAccountTokenMaxExpiration = s.Authentication.ServiceAccounts.MaxExpiration
+	}
+
+	if s.Authentication.ServiceAccounts.KeyServiceURL != "" && len(s.Authentication.ServiceAccounts.Issuers) != 0 {
+		if s.Authentication.ServiceAccounts.MaxExpiration != 0 {
+			lowBound := time.Hour
+			upBound := time.Duration(1<<32) * time.Second
+			if s.Authentication.ServiceAccounts.MaxExpiration < lowBound ||
+				s.Authentication.ServiceAccounts.MaxExpiration > upBound {
+				return options, fmt.Errorf("the serviceaccount max expiration must be between 1 hour to 2^32 seconds")
+			}
+		}
 		s.ServiceAccountTokenMaxExpiration = s.Authentication.ServiceAccounts.MaxExpiration
+		s.ServiceAccountIssuer, err = serviceaccount.ExternalJWTTokenGenerator(
+			s.Authentication.ServiceAccounts.Issuers[0],
+			s.Authentication.ServiceAccounts.KeyServiceURL,
+		)
+		if err != nil {
+			return options, fmt.Errorf("failed to build external token generator: %v", err)
+		}
 	}
 
 	if s.Etcd.EnableWatchCache {
diff --git a/hack/update-generated-externalsigner-dockerized.sh b/hack/update-generated-externalsigner-dockerized.sh
new file mode 100755
index 00000000000..50cf5b9994f
--- /dev/null
+++ b/hack/update-generated-externalsigner-dockerized.sh
@@ -0,0 +1,63 @@
+#!/usr/bin/env bash
+
+# Copyright 2019 The Kubernetes Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -o errexit
+set -o nounset
+set -o pipefail
+
+KUBE_ROOT=$(dirname "${BASH_SOURCE[0]}")/..
+KUBE_EXTERNALSIGNER_GRPC_ROOT="${KUBE_ROOT}/pkg/serviceaccount/externalsigner/v1alpha1"
+source "${KUBE_ROOT}/hack/lib/init.sh"
+
+kube::golang::setup_env
+
+BINS=(
+	vendor/k8s.io/code-generator/cmd/go-to-protobuf/protoc-gen-gogo
+)
+make -C "${KUBE_ROOT}" WHAT="${BINS[*]}"
+
+if [[ -z "$(which protoc)" || "$(protoc --version)" != "libprotoc 3."* ]]; then
+  echo "Generating protobuf requires protoc 3.0.0-beta1 or newer. Please download and"
+  echo "install the platform appropriate Protobuf package for your OS: "
+  echo
+  echo "  https://github.com/google/protobuf/releases"
+  echo
+  echo "WARNING: Protobuf changes are not being validated"
+  exit 1
+fi
+
+function cleanup {
+	rm -f "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/service.pb.go.bak"
+	rm -f "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/service.pb.go.tmp"
+}
+
+trap cleanup EXIT
+
+gogopath=$(dirname "$(kube::util::find-binary "protoc-gen-gogo")")
+
+PATH="${gogopath}:${PATH}" \
+  protoc \
+  --proto_path="${KUBE_EXTERNALSIGNER_GRPC_ROOT}" \
+  --proto_path="${KUBE_ROOT}/vendor" \
+  --gogo_out=plugins=grpc:"${KUBE_EXTERNALSIGNER_GRPC_ROOT}" "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/service.proto"
+
+# Update boilerplate for the generated file.
+cat hack/boilerplate/boilerplate.generatego.txt "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/service.pb.go" > "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/service.pb.go.tmp" && \
+mv "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/service.pb.go.tmp" "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/service.pb.go"
+
+# Run gofmt to clean up the generated code.
+kube::golang::verify_go_version
+gofmt -l -s -w "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/service.pb.go"
diff --git a/hack/update-generated-externalsigner.sh b/hack/update-generated-externalsigner.sh
new file mode 100755
index 00000000000..101207d1230
--- /dev/null
+++ b/hack/update-generated-externalsigner.sh
@@ -0,0 +1,29 @@
+#!/usr/bin/env bash
+
+# Copyright 2019 The Kubernetes Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -o errexit
+set -o nounset
+set -o pipefail
+
+KUBE_ROOT=$(dirname "${BASH_SOURCE[0]}")/..
+
+# NOTE: All output from this script needs to be copied back to the calling
+# source tree.  This is managed in kube::build::copy_output in build/common.sh.
+# If the output set is changed update that function.
+
+"${KUBE_ROOT}/build/run.sh" hack/update-generated-externalsigner-dockerized.sh "$@"
+
+# ex: ts=2 sw=2 et filetype=sh
diff --git a/hack/verify-generated-externalsigner.sh b/hack/verify-generated-externalsigner.sh
new file mode 100755
index 00000000000..8f66dc9b437
--- /dev/null
+++ b/hack/verify-generated-externalsigner.sh
@@ -0,0 +1,45 @@
+#!/usr/bin/env bash
+
+# Copyright 2019 The Kubernetes Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -o errexit
+set -o nounset
+set -o pipefail
+
+KUBE_ROOT=$(dirname "${BASH_SOURCE[0]}")/..
+KUBE_EXTERNALSIGNER_GRPC_ROOT="${KUBE_ROOT}/pkg/serviceaccount/externalsigner/v1alpha1"
+source "${KUBE_ROOT}/hack/lib/init.sh"
+
+kube::golang::setup_env
+
+function cleanup {
+	rm -rf "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/_tmp/"
+}
+
+trap cleanup EXIT
+
+mkdir -p "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/_tmp"
+cp "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/service.pb.go" "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/_tmp/"
+
+ret=0
+KUBE_VERBOSE=3 "${KUBE_ROOT}/hack/update-generated-externalsigner.sh"
+diff -I "gzipped FileDescriptorProto" -I "0x" -Naupr "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/_tmp/service.pb.go" "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/service.pb.go" || ret=$?
+if [[ $ret -eq 0 ]]; then
+    echo "Generated EXTERNALSIGNER gRPC is up to date."
+    cp "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/_tmp/service.pb.go" "${KUBE_EXTERNALSIGNER_GRPC_ROOT}/"
+else
+    echo "Generated EXTERNALSIGNER gRPC is out of date. Please run hack/update-generated-externalsigner.sh"
+    exit 1
+fi
diff --git a/pkg/features/kube_features.go b/pkg/features/kube_features.go
index c1a3e6e7f9a..a774203b534 100644
--- a/pkg/features/kube_features.go
+++ b/pkg/features/kube_features.go
@@ -142,6 +142,12 @@ const (
 	// Postpone deletion of a PV or a PVC when they are being used
 	StorageObjectInUseProtection featuregate.Feature = "StorageObjectInUseProtection"
 
+	// owner: @micahhausler
+	// alpha: v1.16
+	//
+	// External signing of projected service account tokens
+	ExternalKeyService featuregate.Feature = "ExternalKeyService"
+
 	// owner: @saad-ali
 	// ga: 	  v1.10
 	//
@@ -908,6 +914,7 @@ var defaultKubernetesFeatureGates = map[featuregate.Feature]featuregate.FeatureS
 	CPUCFSQuotaPeriod:                              {Default: false, PreRelease: featuregate.Alpha},
 	TopologyManager:                                {Default: true, PreRelease: featuregate.Beta},
 	StorageObjectInUseProtection:                   {Default: true, PreRelease: featuregate.GA, LockToDefault: true}, // remove in 1.25
+	ExternalKeyService:                             {Default: false, PreRelease: featuregate.Alpha},
 	CSIMigration:                                   {Default: true, PreRelease: featuregate.Beta},
 	CSIMigrationGCE:                                {Default: true, PreRelease: featuregate.Beta}, // On by default in 1.23 (requires GCE PD CSI Driver)
 	InTreePluginGCEUnregister:                      {Default: false, PreRelease: featuregate.Alpha},
diff --git a/pkg/kubeapiserver/authenticator/config.go b/pkg/kubeapiserver/authenticator/config.go
index 67f9922abf2..9d6b78c4e57 100644
--- a/pkg/kubeapiserver/authenticator/config.go
+++ b/pkg/kubeapiserver/authenticator/config.go
@@ -36,6 +36,7 @@ import (
 	tokenunion "k8s.io/apiserver/pkg/authentication/token/union"
 	"k8s.io/apiserver/pkg/server/dynamiccertificates"
 	webhookutil "k8s.io/apiserver/pkg/util/webhook"
+	utilfeature "k8s.io/apiserver/pkg/util/feature"
 	"k8s.io/apiserver/plugin/pkg/authenticator/token/oidc"
 	"k8s.io/apiserver/plugin/pkg/authenticator/token/webhook"
 	"k8s.io/kube-openapi/pkg/validation/spec"
@@ -43,6 +44,7 @@ import (
 	// Initialize all known client auth plugins.
 	_ "k8s.io/client-go/plugin/pkg/client/auth"
 	"k8s.io/client-go/util/keyutil"
+	"k8s.io/kubernetes/pkg/features"
 	"k8s.io/kubernetes/pkg/serviceaccount"
 )
 
@@ -64,6 +66,7 @@ type Config struct {
 	ServiceAccountKeyFiles      []string
 	ServiceAccountLookup        bool
 	ServiceAccountIssuers       []string
+	KeyServiceURL               string
 	APIAudiences                authenticator.Audiences
 	WebhookTokenAuthnConfigFile string
 	WebhookTokenAuthnVersion    string
@@ -132,7 +135,7 @@ func (config Config) New() (authenticator.Request, *spec.SecurityDefinitions, er
 		tokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)
 	}
 	if len(config.ServiceAccountIssuers) > 0 {
-		serviceAccountAuth, err := newServiceAccountAuthenticator(config.ServiceAccountIssuers, config.ServiceAccountKeyFiles, config.APIAudiences, config.ServiceAccountTokenGetter)
+		serviceAccountAuth, err := newServiceAccountAuthenticator(config.KeyServiceURL, config.ServiceAccountIssuers, config.ServiceAccountKeyFiles, config.APIAudiences, config.ServiceAccountTokenGetter)
 		if err != nil {
 			return nil, nil, err
 		}
@@ -281,7 +284,11 @@ func newLegacyServiceAccountAuthenticator(keyfiles []string, lookup bool, apiAud
 }
 
 // newServiceAccountAuthenticator returns an authenticator.Token or an error
-func newServiceAccountAuthenticator(issuers []string, keyfiles []string, apiAudiences authenticator.Audiences, serviceAccountGetter serviceaccount.ServiceAccountTokenGetter) (authenticator.Token, error) {
+func newServiceAccountAuthenticator(keyServerURL string, issuers []string, keyfiles []string, apiAudiences authenticator.Audiences, serviceAccountGetter serviceaccount.ServiceAccountTokenGetter) (authenticator.Token, error) {
+	if utilfeature.DefaultFeatureGate.Enabled(features.ExternalKeyService) && keyServerURL != "" {
+		return serviceaccount.ExternalJWTTokenAuthenticator(keyServerURL, issuers, apiAudiences, serviceaccount.NewValidator(serviceAccountGetter))
+	}
+
 	allPublicKeys := []interface{}{}
 	for _, keyfile := range keyfiles {
 		publicKeys, err := keyutil.PublicKeysFromFile(keyfile)
@@ -290,9 +297,7 @@ func newServiceAccountAuthenticator(issuers []string, keyfiles []string, apiAudi
 		}
 		allPublicKeys = append(allPublicKeys, publicKeys...)
 	}
-
-	tokenAuthenticator := serviceaccount.JWTTokenAuthenticator(issuers, allPublicKeys, apiAudiences, serviceaccount.NewValidator(serviceAccountGetter))
-	return tokenAuthenticator, nil
+	return serviceaccount.JWTTokenAuthenticator(issuers, allPublicKeys, apiAudiences, serviceaccount.NewValidator(serviceAccountGetter)), nil
 }
 
 func newWebhookTokenAuthenticator(config Config) (authenticator.Token, error) {
diff --git a/pkg/kubeapiserver/options/authentication.go b/pkg/kubeapiserver/options/authentication.go
index 9fc64598746..732be196e96 100644
--- a/pkg/kubeapiserver/options/authentication.go
+++ b/pkg/kubeapiserver/options/authentication.go
@@ -90,6 +90,7 @@ type ServiceAccountAuthenticationOptions struct {
 	Issuers          []string
 	JWKSURI          string
 	MaxExpiration    time.Duration
+	KeyServiceURL    string
 	ExtendExpiration bool
 }
 
@@ -341,6 +342,9 @@ func (o *BuiltInAuthenticationOptions) AddFlags(fs *pflag.FlagSet) {
 			"and key set are served to relying parties from a URL other than the "+
 			"API server's external (as auto-detected or overridden with external-hostname). ")
 
+		fs.StringVar(&o.ServiceAccounts.KeyServiceURL, "key-service-url", o.ServiceAccounts.KeyServiceURL, ""+
+			"Path to a unix socket for external signing of service account tokens. (Requires the 'TokenRequest' and 'ExternalKeyService' feature gates.)")
+
 		// Deprecated in 1.13
 		fs.StringSliceVar(&o.APIAudiences, "service-account-api-audiences", o.APIAudiences, ""+
 			"Identifiers of the API. The service account token authenticator will validate that "+
@@ -428,6 +432,7 @@ func (o *BuiltInAuthenticationOptions) ToAuthenticationConfig() (kubeauthenticat
 		ret.ServiceAccountKeyFiles = o.ServiceAccounts.KeyFiles
 		ret.ServiceAccountIssuers = o.ServiceAccounts.Issuers
 		ret.ServiceAccountLookup = o.ServiceAccounts.Lookup
+		ret.KeyServiceURL = o.ServiceAccounts.KeyServiceURL
 	}
 
 	if o.TokenFile != nil {
diff --git a/pkg/serviceaccount/externalsigner/v1alpha1/service.pb.go b/pkg/serviceaccount/externalsigner/v1alpha1/service.pb.go
new file mode 100644
index 00000000000..fe3aedbca65
--- /dev/null
+++ b/pkg/serviceaccount/externalsigner/v1alpha1/service.pb.go
@@ -0,0 +1,317 @@
+/*
+Copyright The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by protoc-gen-gogo. DO NOT EDIT.
+// source: service.proto
+
+/*
+Package v1alpha1 is a generated protocol buffer package.
+
+It is generated from these files:
+	service.proto
+
+It has these top-level messages:
+	SignPayloadRequest
+	SignPayloadResponse
+	PublicKey
+	ListPublicKeysRequest
+	ListPublicKeysResponse
+*/
+package v1alpha1
+
+import proto "github.com/gogo/protobuf/proto"
+import fmt "fmt"
+import math "math"
+
+import (
+	context "golang.org/x/net/context"
+	grpc "google.golang.org/grpc"
+)
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = fmt.Errorf
+var _ = math.Inf
+
+// This is a compile-time assertion to ensure that this generated file
+// is compatible with the proto package it is being compiled against.
+// A compilation error at this line likely means your copy of the
+// proto package needs to be updated.
+const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package
+
+type SignPayloadRequest struct {
+	// payload is the content to be signed
+	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
+	// algorithm specifies which algorithm to sign with
+	Algorithm string `protobuf:"bytes,2,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
+}
+
+func (m *SignPayloadRequest) Reset()                    { *m = SignPayloadRequest{} }
+func (m *SignPayloadRequest) String() string            { return proto.CompactTextString(m) }
+func (*SignPayloadRequest) ProtoMessage()               {}
+func (*SignPayloadRequest) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{0} }
+
+func (m *SignPayloadRequest) GetPayload() []byte {
+	if m != nil {
+		return m.Payload
+	}
+	return nil
+}
+
+func (m *SignPayloadRequest) GetAlgorithm() string {
+	if m != nil {
+		return m.Algorithm
+	}
+	return ""
+}
+
+type SignPayloadResponse struct {
+	// content returns the signed payload
+	Content []byte `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
+}
+
+func (m *SignPayloadResponse) Reset()                    { *m = SignPayloadResponse{} }
+func (m *SignPayloadResponse) String() string            { return proto.CompactTextString(m) }
+func (*SignPayloadResponse) ProtoMessage()               {}
+func (*SignPayloadResponse) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{1} }
+
+func (m *SignPayloadResponse) GetContent() []byte {
+	if m != nil {
+		return m.Content
+	}
+	return nil
+}
+
+type PublicKey struct {
+	// public_key is a PEM encoded public key
+	PublicKey []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
+	// certificate is a concatenated list of PEM encoded x509 certificates
+	Certificates []byte `protobuf:"bytes,2,opt,name=certificates,proto3" json:"certificates,omitempty"`
+	// key_id is the key's ID
+	KeyId string `protobuf:"bytes,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
+	// algorithm states the algorithm the key uses
+	Algorithm string `protobuf:"bytes,4,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
+}
+
+func (m *PublicKey) Reset()                    { *m = PublicKey{} }
+func (m *PublicKey) String() string            { return proto.CompactTextString(m) }
+func (*PublicKey) ProtoMessage()               {}
+func (*PublicKey) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{2} }
+
+func (m *PublicKey) GetPublicKey() []byte {
+	if m != nil {
+		return m.PublicKey
+	}
+	return nil
+}
+
+func (m *PublicKey) GetCertificates() []byte {
+	if m != nil {
+		return m.Certificates
+	}
+	return nil
+}
+
+func (m *PublicKey) GetKeyId() string {
+	if m != nil {
+		return m.KeyId
+	}
+	return ""
+}
+
+func (m *PublicKey) GetAlgorithm() string {
+	if m != nil {
+		return m.Algorithm
+	}
+	return ""
+}
+
+type ListPublicKeysRequest struct {
+}
+
+func (m *ListPublicKeysRequest) Reset()                    { *m = ListPublicKeysRequest{} }
+func (m *ListPublicKeysRequest) String() string            { return proto.CompactTextString(m) }
+func (*ListPublicKeysRequest) ProtoMessage()               {}
+func (*ListPublicKeysRequest) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{3} }
+
+type ListPublicKeysResponse struct {
+	// active_key_id is the active signing key's ID
+	ActiveKeyId string `protobuf:"bytes,1,opt,name=active_key_id,json=activeKeyId,proto3" json:"active_key_id,omitempty"`
+	// public_keys is a list of public verifying keys
+	PublicKeys []*PublicKey `protobuf:"bytes,2,rep,name=public_keys,json=publicKeys" json:"public_keys,omitempty"`
+}
+
+func (m *ListPublicKeysResponse) Reset()                    { *m = ListPublicKeysResponse{} }
+func (m *ListPublicKeysResponse) String() string            { return proto.CompactTextString(m) }
+func (*ListPublicKeysResponse) ProtoMessage()               {}
+func (*ListPublicKeysResponse) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{4} }
+
+func (m *ListPublicKeysResponse) GetActiveKeyId() string {
+	if m != nil {
+		return m.ActiveKeyId
+	}
+	return ""
+}
+
+func (m *ListPublicKeysResponse) GetPublicKeys() []*PublicKey {
+	if m != nil {
+		return m.PublicKeys
+	}
+	return nil
+}
+
+func init() {
+	proto.RegisterType((*SignPayloadRequest)(nil), "v1alpha1.SignPayloadRequest")
+	proto.RegisterType((*SignPayloadResponse)(nil), "v1alpha1.SignPayloadResponse")
+	proto.RegisterType((*PublicKey)(nil), "v1alpha1.PublicKey")
+	proto.RegisterType((*ListPublicKeysRequest)(nil), "v1alpha1.ListPublicKeysRequest")
+	proto.RegisterType((*ListPublicKeysResponse)(nil), "v1alpha1.ListPublicKeysResponse")
+}
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ context.Context
+var _ grpc.ClientConn
+
+// This is a compile-time assertion to ensure that this generated file
+// is compatible with the grpc package it is being compiled against.
+const _ = grpc.SupportPackageIsVersion4
+
+// Client API for KeyService service
+
+type KeyServiceClient interface {
+	// Sign an incoming payload
+	SignPayload(ctx context.Context, in *SignPayloadRequest, opts ...grpc.CallOption) (*SignPayloadResponse, error)
+	// List all active public keys
+	ListPublicKeys(ctx context.Context, in *ListPublicKeysRequest, opts ...grpc.CallOption) (*ListPublicKeysResponse, error)
+}
+
+type keyServiceClient struct {
+	cc *grpc.ClientConn
+}
+
+func NewKeyServiceClient(cc *grpc.ClientConn) KeyServiceClient {
+	return &keyServiceClient{cc}
+}
+
+func (c *keyServiceClient) SignPayload(ctx context.Context, in *SignPayloadRequest, opts ...grpc.CallOption) (*SignPayloadResponse, error) {
+	out := new(SignPayloadResponse)
+	err := grpc.Invoke(ctx, "/v1alpha1.KeyService/SignPayload", in, out, c.cc, opts...)
+	if err != nil {
+		return nil, err
+	}
+	return out, nil
+}
+
+func (c *keyServiceClient) ListPublicKeys(ctx context.Context, in *ListPublicKeysRequest, opts ...grpc.CallOption) (*ListPublicKeysResponse, error) {
+	out := new(ListPublicKeysResponse)
+	err := grpc.Invoke(ctx, "/v1alpha1.KeyService/ListPublicKeys", in, out, c.cc, opts...)
+	if err != nil {
+		return nil, err
+	}
+	return out, nil
+}
+
+// Server API for KeyService service
+
+type KeyServiceServer interface {
+	// Sign an incoming payload
+	SignPayload(context.Context, *SignPayloadRequest) (*SignPayloadResponse, error)
+	// List all active public keys
+	ListPublicKeys(context.Context, *ListPublicKeysRequest) (*ListPublicKeysResponse, error)
+}
+
+func RegisterKeyServiceServer(s *grpc.Server, srv KeyServiceServer) {
+	s.RegisterService(&_KeyService_serviceDesc, srv)
+}
+
+func _KeyService_SignPayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	in := new(SignPayloadRequest)
+	if err := dec(in); err != nil {
+		return nil, err
+	}
+	if interceptor == nil {
+		return srv.(KeyServiceServer).SignPayload(ctx, in)
+	}
+	info := &grpc.UnaryServerInfo{
+		Server:     srv,
+		FullMethod: "/v1alpha1.KeyService/SignPayload",
+	}
+	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
+		return srv.(KeyServiceServer).SignPayload(ctx, req.(*SignPayloadRequest))
+	}
+	return interceptor(ctx, in, info, handler)
+}
+
+func _KeyService_ListPublicKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	in := new(ListPublicKeysRequest)
+	if err := dec(in); err != nil {
+		return nil, err
+	}
+	if interceptor == nil {
+		return srv.(KeyServiceServer).ListPublicKeys(ctx, in)
+	}
+	info := &grpc.UnaryServerInfo{
+		Server:     srv,
+		FullMethod: "/v1alpha1.KeyService/ListPublicKeys",
+	}
+	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
+		return srv.(KeyServiceServer).ListPublicKeys(ctx, req.(*ListPublicKeysRequest))
+	}
+	return interceptor(ctx, in, info, handler)
+}
+
+var _KeyService_serviceDesc = grpc.ServiceDesc{
+	ServiceName: "v1alpha1.KeyService",
+	HandlerType: (*KeyServiceServer)(nil),
+	Methods: []grpc.MethodDesc{
+		{
+			MethodName: "SignPayload",
+			Handler:    _KeyService_SignPayload_Handler,
+		},
+		{
+			MethodName: "ListPublicKeys",
+			Handler:    _KeyService_ListPublicKeys_Handler,
+		},
+	},
+	Streams:  []grpc.StreamDesc{},
+	Metadata: "service.proto",
+}
+
+func init() { proto.RegisterFile("service.proto", fileDescriptorService) }
+
+var fileDescriptorService = []byte{
+	// 316 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x52, 0x4d, 0x4f, 0x02, 0x31,
+	0x10, 0x75, 0x45, 0xd1, 0x9d, 0x05, 0x0f, 0x25, 0xe8, 0x86, 0x40, 0x24, 0x3d, 0x71, 0xc2, 0x80,
+	0xfe, 0x09, 0x03, 0x07, 0xb2, 0xc4, 0x33, 0x29, 0x65, 0x84, 0x86, 0x75, 0x5b, 0xb7, 0x85, 0xa4,
+	0x67, 0x7f, 0x91, 0xff, 0xd0, 0xd0, 0xfd, 0x12, 0x94, 0xe3, 0xbc, 0xe9, 0xbc, 0x79, 0xef, 0x4d,
+	0xa1, 0xa9, 0x31, 0xdd, 0x0b, 0x8e, 0x43, 0x95, 0x4a, 0x23, 0xc9, 0xed, 0x7e, 0xc4, 0x62, 0xb5,
+	0x61, 0x23, 0x3a, 0x05, 0x32, 0x17, 0xeb, 0x64, 0xc6, 0x6c, 0x2c, 0xd9, 0x2a, 0xc2, 0xcf, 0x1d,
+	0x6a, 0x43, 0x42, 0xb8, 0x51, 0x19, 0x12, 0x7a, 0x7d, 0x6f, 0xd0, 0x88, 0x8a, 0x92, 0x74, 0xc1,
+	0x67, 0xf1, 0x5a, 0xa6, 0xc2, 0x6c, 0x3e, 0xc2, 0xcb, 0xbe, 0x37, 0xf0, 0xa3, 0x0a, 0xa0, 0x4f,
+	0xd0, 0x3a, 0x62, 0xd3, 0x4a, 0x26, 0x1a, 0x0f, 0x74, 0x5c, 0x26, 0x06, 0x13, 0x53, 0xd0, 0xe5,
+	0x25, 0xfd, 0xf2, 0xc0, 0x9f, 0xed, 0x96, 0xb1, 0xe0, 0x13, 0xb4, 0xa4, 0x07, 0xa0, 0x5c, 0xb1,
+	0xd8, 0xa2, 0xcd, 0x9f, 0xfa, 0xaa, 0x6c, 0x53, 0x68, 0x70, 0x4c, 0x8d, 0x78, 0x17, 0x9c, 0x19,
+	0xd4, 0x6e, 0x7d, 0x23, 0x3a, 0xc2, 0x48, 0x1b, 0xea, 0x5b, 0xb4, 0x0b, 0xb1, 0x0a, 0x6b, 0x4e,
+	0xdc, 0xf5, 0x16, 0xed, 0xeb, 0x89, 0xec, 0xab, 0x53, 0xd9, 0x0f, 0xd0, 0x9e, 0x0a, 0x6d, 0x4a,
+	0x21, 0x3a, 0xcf, 0x81, 0xa6, 0x70, 0x7f, 0xda, 0xc8, 0x2d, 0x51, 0x68, 0x32, 0x6e, 0xc4, 0x1e,
+	0x17, 0xf9, 0x3a, 0xcf, 0x91, 0x06, 0x19, 0x38, 0x71, 0x4b, 0x5f, 0x20, 0xa8, 0xec, 0x1c, 0xe4,
+	0xd6, 0x06, 0xc1, 0xb8, 0x35, 0x2c, 0xb2, 0x1f, 0x96, 0xb4, 0x11, 0x94, 0x26, 0xf5, 0xf8, 0xdb,
+	0x03, 0x98, 0xa0, 0x9d, 0x67, 0x07, 0x23, 0x53, 0x08, 0x7e, 0x45, 0x4a, 0xba, 0xd5, 0xf8, 0xdf,
+	0xbb, 0x75, 0x7a, 0x67, 0xba, 0x99, 0x68, 0x7a, 0x41, 0xde, 0xe0, 0xee, 0xd8, 0x10, 0x79, 0xac,
+	0x46, 0xfe, 0xcd, 0xa0, 0xd3, 0x3f, 0xff, 0xa0, 0xa0, 0x5d, 0xd6, 0xdd, 0xb7, 0x7a, 0xfe, 0x09,
+	0x00, 0x00, 0xff, 0xff, 0x8c, 0x5a, 0xf9, 0x01, 0x67, 0x02, 0x00, 0x00,
+}
diff --git a/pkg/serviceaccount/externalsigner/v1alpha1/service.proto b/pkg/serviceaccount/externalsigner/v1alpha1/service.proto
new file mode 100644
index 00000000000..cd8036f501b
--- /dev/null
+++ b/pkg/serviceaccount/externalsigner/v1alpha1/service.proto
@@ -0,0 +1,40 @@
+syntax = "proto3";
+
+package v1alpha1;
+
+service KeyService {
+  // Sign an incoming payload
+  rpc SignPayload(SignPayloadRequest) returns (SignPayloadResponse) {}
+  // List all active public keys
+  rpc ListPublicKeys(ListPublicKeysRequest) returns (ListPublicKeysResponse) {}
+}
+
+message SignPayloadRequest {
+  // payload is the content to be signed
+  bytes payload = 1;
+  // algorithm specifies which algorithm to sign with
+  string algorithm = 2;
+}
+message SignPayloadResponse {
+  // content returns the signed payload
+  bytes content = 1;
+}
+
+message PublicKey {
+  // public_key is a PEM encoded public key
+  bytes public_key = 1;
+  // certificate is a concatenated list of PEM encoded x509 certificates
+  bytes certificates = 2;
+  // key_id is the key's ID
+  string key_id = 3;
+  // algorithm states the algorithm the key uses
+  string algorithm = 4;
+}
+
+message ListPublicKeysRequest {}
+message ListPublicKeysResponse {
+  // active_key_id is the active signing key's ID
+  string active_key_id = 1;
+  // public_keys is a list of public verifying keys
+  repeated PublicKey public_keys = 2;
+}
diff --git a/pkg/serviceaccount/jwt.go b/pkg/serviceaccount/jwt.go
index 6722b206d1d..96765506aa5 100644
--- a/pkg/serviceaccount/jwt.go
+++ b/pkg/serviceaccount/jwt.go
@@ -174,7 +174,11 @@ func signerFromECDSAPrivateKey(keyPair *ecdsa.PrivateKey) (jose.Signer, error) {
 			Algorithm: alg,
 			Key:       privateJWK,
 		},
-		nil,
+		&jose.SignerOptions{
+			ExtraHeaders: map[jose.HeaderKey]interface{}{
+				jose.HeaderKey("kid"): keyID,
+			},
+		},
 	)
 	if err != nil {
 		return nil, fmt.Errorf("failed to create signer: %v", err)
@@ -184,7 +188,9 @@ func signerFromECDSAPrivateKey(keyPair *ecdsa.PrivateKey) (jose.Signer, error) {
 }
 
 func signerFromOpaqueSigner(opaqueSigner jose.OpaqueSigner) (jose.Signer, error) {
-	alg := jose.SignatureAlgorithm(opaqueSigner.Public().Algorithm)
+	publicKey := opaqueSigner.Public()
+	alg := jose.SignatureAlgorithm(publicKey.Algorithm)
+	keyID := publicKey.KeyID
 
 	signer, err := jose.NewSigner(
 		jose.SigningKey{
@@ -192,11 +198,15 @@ func signerFromOpaqueSigner(opaqueSigner jose.OpaqueSigner) (jose.Signer, error)
 			Key: &jose.JSONWebKey{
 				Algorithm: string(alg),
 				Key:       opaqueSigner,
-				KeyID:     opaqueSigner.Public().KeyID,
+				KeyID:     keyID,
 				Use:       "sig",
 			},
 		},
-		nil,
+		&jose.SignerOptions{
+			ExtraHeaders: map[jose.HeaderKey]interface{}{
+				jose.HeaderKey("kid"): keyID,
+			},
+		},
 	)
 	if err != nil {
 		return nil, fmt.Errorf("failed to create signer: %v", err)
diff --git a/pkg/serviceaccount/jwt_external.go b/pkg/serviceaccount/jwt_external.go
new file mode 100644
index 00000000000..29014dfbac1
--- /dev/null
+++ b/pkg/serviceaccount/jwt_external.go
@@ -0,0 +1,187 @@
+/*
+Copyright 2019 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package serviceaccount
+
+import (
+	"context"
+	"fmt"
+
+	"google.golang.org/grpc"
+	jose "gopkg.in/square/go-jose.v2"
+	"gopkg.in/square/go-jose.v2/jwt"
+
+	"k8s.io/apiserver/pkg/authentication/authenticator"
+	certutil "k8s.io/client-go/util/cert"
+	"k8s.io/client-go/util/keyutil"
+	"k8s.io/klog/v2"
+	externalsigner "k8s.io/kubernetes/pkg/serviceaccount/externalsigner/v1alpha1"
+)
+
+// ExternalJWTTokenGenerator returns a TokenGenerator that generates signed JWT Tokens using a remote signing service
+func ExternalJWTTokenGenerator(iss string, socketPath string) (TokenGenerator, error) {
+	// TODO: @micahhausler conditionally add unix:// prefix
+	conn, err := grpc.Dial(fmt.Sprintf("unix://%s", socketPath), grpc.WithInsecure())
+	if err != nil {
+		return nil, err
+	}
+	generator := &ExternalTokenGenerator{
+		Iss:    iss,
+		Client: externalsigner.NewKeyServiceClient(conn),
+	}
+	return generator, nil
+}
+
+var _ TokenGenerator = &ExternalTokenGenerator{}
+
+type ExternalTokenGenerator struct {
+	Iss    string
+	Client externalsigner.KeyServiceClient
+}
+
+func (g *ExternalTokenGenerator) GenerateToken(claims *jwt.Claims, privateClaims interface{}) (string, error) {
+	signer := NewRemoteOpaqueSigner(g.Client)
+	generator, err := JWTTokenGenerator(g.Iss, signer)
+	if err != nil {
+		return "", err
+	}
+	return generator.GenerateToken(claims, privateClaims)
+}
+
+// NewRemoteOpaqueSigner returns an jose.OpaqueSigner that communicates over the client
+func NewRemoteOpaqueSigner(client externalsigner.KeyServiceClient) *RemoteOpaqueSigner {
+	return &RemoteOpaqueSigner{Client: client}
+}
+
+type RemoteOpaqueSigner struct {
+	Client externalsigner.KeyServiceClient
+}
+
+// check that OpaqueSigner conforms to the interface
+var _ jose.OpaqueSigner = &RemoteOpaqueSigner{}
+
+func (s *RemoteOpaqueSigner) Public() *jose.JSONWebKey {
+	resp, err := s.Client.ListPublicKeys(context.Background(), &externalsigner.ListPublicKeysRequest{})
+	if err != nil {
+		klog.Errorf("Error getting public keys: %v", err)
+		return nil
+	}
+	var currentPublicKey *externalsigner.PublicKey
+	for _, key := range resp.PublicKeys {
+		if resp.ActiveKeyId == key.KeyId {
+			currentPublicKey = key
+			break
+		}
+	}
+	if currentPublicKey == nil {
+		klog.Errorf("Current key_id %s not found in list", resp.ActiveKeyId)
+		return nil
+	}
+	response := &jose.JSONWebKey{
+		KeyID:     currentPublicKey.KeyId,
+		Algorithm: currentPublicKey.Algorithm,
+		Use:       "sig",
+	}
+	keys, err := keyutil.ParsePublicKeysPEM(currentPublicKey.PublicKey)
+	if err != nil {
+		klog.Errorf("Error getting public key: %v", err)
+		return nil
+	}
+	if len(keys) == 0 {
+		klog.Error("No public key returned")
+		return nil
+	}
+	response.Key = keys[0]
+	response.Certificates, err = certutil.ParseCertsPEM(currentPublicKey.Certificates)
+	if err != nil && err != certutil.ErrNoCerts {
+		klog.Errorf("Error parsing x509 certificate: %v", err)
+		return nil
+	}
+	return response
+}
+
+func (s *RemoteOpaqueSigner) Algs() []jose.SignatureAlgorithm {
+	resp, err := s.Client.ListPublicKeys(context.Background(), &externalsigner.ListPublicKeysRequest{})
+	if err != nil {
+		klog.Errorf("Error getting public keys: %v", err)
+		return nil
+	}
+	algos := map[string]bool{}
+	for _, key := range resp.PublicKeys {
+		algos[key.Algorithm] = true
+	}
+	response := []jose.SignatureAlgorithm{}
+	for alg := range algos {
+		response = append(response, jose.SignatureAlgorithm(alg))
+	}
+	return response
+}
+
+func (s *RemoteOpaqueSigner) SignPayload(payload []byte, alg jose.SignatureAlgorithm) ([]byte, error) {
+	resp, err := s.Client.SignPayload(context.Background(), &externalsigner.SignPayloadRequest{
+		Payload:   payload,
+		Algorithm: string(alg),
+	})
+	if err != nil {
+		return nil, err
+	}
+	return resp.Content, nil
+}
+
+type ExternalTokenAuthenticator struct {
+	Client       externalsigner.KeyServiceClient
+	Issuers      []string
+	Validator    Validator
+	ImplicitAuds authenticator.Audiences
+}
+
+func (a *ExternalTokenAuthenticator) AuthenticateToken(ctx context.Context, tokenData string) (*authenticator.Response, bool, error) {
+	keyResp, err := a.Client.ListPublicKeys(ctx, &externalsigner.ListPublicKeysRequest{})
+	if err != nil {
+		return nil, false, err
+	}
+	var keyData []byte
+	for _, pubKey := range keyResp.PublicKeys {
+		keyData = append(keyData, pubKey.PublicKey...)
+		keyData = append(keyData, '\n')
+	}
+	keys, err := keyutil.ParsePublicKeysPEM(keyData)
+	if err != nil {
+		return nil, false, err
+	}
+	return JWTTokenAuthenticator(
+		a.Issuers,
+		keys,
+		a.ImplicitAuds,
+		a.Validator,
+	).AuthenticateToken(
+		ctx, tokenData,
+	)
+}
+
+// ExternalJWTTokenAuthenticator authenticates JWT tokens signed externally
+func ExternalJWTTokenAuthenticator(socketPath string, issuers []string, implicitAuds authenticator.Audiences, validator Validator) (authenticator.Token, error) {
+	conn, err := grpc.Dial(fmt.Sprintf("unix://%s", socketPath), grpc.WithInsecure())
+	if err != nil {
+		return nil, err
+	}
+	return &ExternalTokenAuthenticator{
+		Client:       externalsigner.NewKeyServiceClient(conn),
+		Issuers:      issuers,
+		Validator:    validator,
+		ImplicitAuds: implicitAuds,
+	}, nil
+}
diff --git a/pkg/serviceaccount/jwt_external_test.go b/pkg/serviceaccount/jwt_external_test.go
new file mode 100644
index 00000000000..d806e346589
--- /dev/null
+++ b/pkg/serviceaccount/jwt_external_test.go
@@ -0,0 +1,128 @@
+/*
+Copyright 2019 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package serviceaccount_test
+
+import (
+	"context"
+	"crypto"
+	"crypto/ecdsa"
+	"crypto/elliptic"
+	"crypto/rsa"
+	"crypto/sha1"
+	"crypto/x509"
+	"encoding/pem"
+	"fmt"
+
+	"google.golang.org/grpc"
+	jose "gopkg.in/square/go-jose.v2"
+	"gopkg.in/square/go-jose.v2/cryptosigner"
+
+	externalsigner "k8s.io/kubernetes/pkg/serviceaccount/externalsigner/v1alpha1"
+)
+
+func rsaPubKeyBytes(pk *rsa.PrivateKey) ([]byte, error) {
+	if pk == nil {
+		return nil, fmt.Errorf("No private key!")
+	}
+	return pubKeyPKIX(&pk.PublicKey)
+}
+
+func pubKeyPKIX(kU interface{}) ([]byte, error) {
+	der, err := x509.MarshalPKIXPublicKey(kU)
+	if err != nil {
+		return nil, fmt.Errorf("Could not marshal public key (%T): %v", kU, err)
+	}
+	block := pem.Block{
+		Type:  "PUBLIC KEY",
+		Bytes: der,
+	}
+	return pem.EncodeToMemory(&block), nil
+}
+
+var _ externalsigner.KeyServiceClient = &mockKeyServiceClient{}
+
+func newMockKeyServiceClient(privatekey interface{}) *mockKeyServiceClient {
+	return &mockKeyServiceClient{
+		key: privatekey,
+	}
+}
+
+type mockKeyServiceClient struct {
+	key interface{}
+}
+
+func (c *mockKeyServiceClient) SignPayload(ctx context.Context, in *externalsigner.SignPayloadRequest, opts ...grpc.CallOption) (*externalsigner.SignPayloadResponse, error) {
+	cSigner, ok := c.key.(crypto.Signer)
+	if !ok {
+		return nil, fmt.Errorf("private key type %T must be a valid crypto.Signer", c.key)
+	}
+	signer := cryptosigner.Opaque(cSigner)
+	signedData, err := signer.SignPayload(in.Payload, jose.SignatureAlgorithm(in.Algorithm))
+	if err != nil {
+		return nil, err
+	}
+	return &externalsigner.SignPayloadResponse{
+		Content: signedData,
+	}, nil
+}
+
+func (c *mockKeyServiceClient) ListPublicKeys(ctx context.Context, in *externalsigner.ListPublicKeysRequest, opts ...grpc.CallOption) (*externalsigner.ListPublicKeysResponse, error) {
+	var alg jose.SignatureAlgorithm
+	var kU []byte
+	var err error
+	switch pk := c.key.(type) {
+	case *rsa.PrivateKey:
+		alg = jose.RS256
+		kU, err = pubKeyPKIX(&pk.PublicKey)
+		if err != nil {
+			return nil, err
+		}
+	case *ecdsa.PrivateKey:
+		kU, err = pubKeyPKIX(&pk.PublicKey)
+		if err != nil {
+			return nil, err
+		}
+		switch pk.Curve {
+		case elliptic.P256():
+			alg = jose.ES256
+		case elliptic.P384():
+			alg = jose.ES384
+		case elliptic.P521():
+			alg = jose.ES512
+		default:
+			return nil, fmt.Errorf("unknown private key curve, must be 256, 384, or 521")
+		}
+	default:
+		return nil, fmt.Errorf("unknown private key type %T, must be *rsa.PrivateKey, *ecdsa.PrivateKey", pk)
+	}
+
+	// for simplicity purposes, KeyID is the sha1sum(PKIX(pubkey))
+	kid := fmt.Sprintf("%x", sha1.Sum(kU))
+
+	keys := []*externalsigner.PublicKey{
+		{
+			PublicKey: kU,
+			KeyId:     kid,
+			Algorithm: string(alg),
+		},
+	}
+	return &externalsigner.ListPublicKeysResponse{
+		ActiveKeyId: kid,
+		PublicKeys:  keys,
+	}, nil
+
+}
diff --git a/pkg/serviceaccount/jwt_test.go b/pkg/serviceaccount/jwt_test.go
index ded059f412e..fbace2fb7f2 100644
--- a/pkg/serviceaccount/jwt_test.go
+++ b/pkg/serviceaccount/jwt_test.go
@@ -33,8 +33,10 @@ import (
 	v1listers "k8s.io/client-go/listers/core/v1"
 	"k8s.io/client-go/tools/cache"
 	"k8s.io/client-go/util/keyutil"
+	"k8s.io/kubernetes/pkg/apis/core"
 	serviceaccountcontroller "k8s.io/kubernetes/pkg/controller/serviceaccount"
 	"k8s.io/kubernetes/pkg/serviceaccount"
+	externalsigner "k8s.io/kubernetes/pkg/serviceaccount/externalsigner/v1alpha1"
 )
 
 const otherPublicKey = `-----BEGIN PUBLIC KEY-----
@@ -133,6 +135,7 @@ func getPublicKey(data string) interface{} {
 }
 
 func TestTokenGenerateAndValidate(t *testing.T) {
+	newIssuer := []string{serviceaccount.LegacyIssuer, "bar"}
 	expectedUserName := "system:serviceaccount:test:my-service-account"
 	expectedUserUID := "12345"
 
@@ -144,6 +147,13 @@ func TestTokenGenerateAndValidate(t *testing.T) {
 			Namespace: "test",
 		},
 	}
+	coreSa := core.ServiceAccount{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      "my-service-account",
+			UID:       "12345",
+			Namespace: "test",
+		},
+	}
 	rsaSecret := &v1.Secret{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      "my-rsa-secret",
@@ -193,6 +203,21 @@ func TestTokenGenerateAndValidate(t *testing.T) {
 
 	checkJSONWebSignatureHasKeyID(t, ecdsaToken, ecdsaKeyID)
 
+	// Generate the remote RSA token
+	remoteRsaGenerator := serviceaccount.ExternalTokenGenerator{
+		Iss:    newIssuer[0],
+		Client: newMockKeyServiceClient(getPrivateKey(rsaPrivateKey)),
+	}
+	remoteRsaToken, err := remoteRsaGenerator.GenerateToken(
+		serviceaccount.Claims(coreSa, nil, nil, 60*60*24, 0, []string{"kubernetes"}),
+	)
+	if err != nil {
+		t.Fatalf("error generating token: %v", err)
+	}
+	if len(remoteRsaToken) == 0 {
+		t.Fatalf("no token generated")
+	}
+
 	// Generate signer with same keys as RSA signer but different unrecognized issuer
 	badIssuerGenerator, err := serviceaccount.JWTTokenGenerator("foo", getPrivateKey(rsaPrivateKey))
 	if err != nil {
@@ -218,11 +243,14 @@ func TestTokenGenerateAndValidate(t *testing.T) {
 		Keys   []interface{}
 		Token  string
 
-		ExpectedErr      bool
-		ExpectedOK       bool
-		ExpectedUserName string
-		ExpectedUserUID  string
-		ExpectedGroups   []string
+		ExpectedErr           bool
+		ExpectedOK            bool
+		ExpectedUserName      string
+		ExpectedUserUID       string
+		ExpectedGroups        []string
+		Authenticator         authenticator.Token
+		ExternalServiceClient externalsigner.KeyServiceClient
+		Issuer                []string
 	}{
 		"no keys": {
 			Token:       rsaToken,
@@ -326,58 +354,93 @@ func TestTokenGenerateAndValidate(t *testing.T) {
 			ExpectedErr: true,
 			ExpectedOK:  false,
 		},
+		"valid (external rsa)": {
+			Token:                 remoteRsaToken,
+			Client:                fake.NewSimpleClientset(serviceAccount),
+			Keys:                  nil,
+			ExpectedErr:           false,
+			ExpectedOK:            true,
+			ExpectedUserName:      expectedUserName,
+			ExpectedUserUID:       expectedUserUID,
+			ExpectedGroups:        []string{"system:serviceaccounts", "system:serviceaccounts:test"},
+			ExternalServiceClient: newMockKeyServiceClient(getPrivateKey(rsaPrivateKey)),
+			Issuer:                newIssuer,
+		},
+		"invalid key (external)": {
+			Token:                 remoteRsaToken,
+			Client:                fake.NewSimpleClientset(serviceAccount),
+			Keys:                  nil,
+			ExpectedErr:           true,
+			ExpectedOK:            false,
+			ExpectedUserName:      expectedUserName,
+			ExpectedUserUID:       expectedUserUID,
+			ExpectedGroups:        []string{"system:serviceaccounts", "system:serviceaccounts:test"},
+			ExternalServiceClient: newMockKeyServiceClient(getPrivateKey(ecdsaPrivateKey)),
+			Issuer:                newIssuer,
+		},
 	}
 
 	for k, tc := range testCases {
-		auds := authenticator.Audiences{"api"}
-		getter := serviceaccountcontroller.NewGetterFromClient(
-			tc.Client,
-			v1listers.NewSecretLister(newIndexer(func(namespace, name string) (interface{}, error) {
-				return tc.Client.CoreV1().Secrets(namespace).Get(context.TODO(), name, metav1.GetOptions{})
-			})),
-			v1listers.NewServiceAccountLister(newIndexer(func(namespace, name string) (interface{}, error) {
-				return tc.Client.CoreV1().ServiceAccounts(namespace).Get(context.TODO(), name, metav1.GetOptions{})
-			})),
-			v1listers.NewPodLister(newIndexer(func(namespace, name string) (interface{}, error) {
-				return tc.Client.CoreV1().Pods(namespace).Get(context.TODO(), name, metav1.GetOptions{})
-			})),
-		)
-		authn := serviceaccount.JWTTokenAuthenticator([]string{serviceaccount.LegacyIssuer, "bar"}, tc.Keys, auds, serviceaccount.NewLegacyValidator(tc.Client != nil, getter))
-
-		// An invalid, non-JWT token should always fail
-		ctx := authenticator.WithAudiences(context.Background(), auds)
-		if _, ok, err := authn.AuthenticateToken(ctx, "invalid token"); err != nil || ok {
-			t.Errorf("%s: Expected err=nil, ok=false for non-JWT token", k)
-			continue
-		}
-
-		resp, ok, err := authn.AuthenticateToken(ctx, tc.Token)
-		if (err != nil) != tc.ExpectedErr {
-			t.Errorf("%s: Expected error=%v, got %v", k, tc.ExpectedErr, err)
-			continue
-		}
-
-		if ok != tc.ExpectedOK {
-			t.Errorf("%s: Expected ok=%v, got %v", k, tc.ExpectedOK, ok)
-			continue
-		}
-
-		if err != nil || !ok {
-			continue
-		}
-
-		if resp.User.GetName() != tc.ExpectedUserName {
-			t.Errorf("%s: Expected username=%v, got %v", k, tc.ExpectedUserName, resp.User.GetName())
-			continue
-		}
-		if resp.User.GetUID() != tc.ExpectedUserUID {
-			t.Errorf("%s: Expected userUID=%v, got %v", k, tc.ExpectedUserUID, resp.User.GetUID())
-			continue
-		}
-		if !reflect.DeepEqual(resp.User.GetGroups(), tc.ExpectedGroups) {
-			t.Errorf("%s: Expected groups=%v, got %v", k, tc.ExpectedGroups, resp.User.GetGroups())
-			continue
-		}
+		t.Run(fmt.Sprintf("case %s", k), func(t *testing.T) {
+			auds := authenticator.Audiences{"api"}
+			getter := serviceaccountcontroller.NewGetterFromClient(
+				tc.Client,
+				v1listers.NewSecretLister(newIndexer(func(namespace, name string) (interface{}, error) {
+					return tc.Client.CoreV1().Secrets(namespace).Get(context.TODO(), name, metav1.GetOptions{})
+				})),
+				v1listers.NewServiceAccountLister(newIndexer(func(namespace, name string) (interface{}, error) {
+					return tc.Client.CoreV1().ServiceAccounts(namespace).Get(context.TODO(), name, metav1.GetOptions{})
+				})),
+				v1listers.NewPodLister(newIndexer(func(namespace, name string) (interface{}, error) {
+					return tc.Client.CoreV1().Pods(namespace).Get(context.TODO(), name, metav1.GetOptions{})
+				})),
+			)
+			var authn authenticator.Token
+			if tc.ExternalServiceClient != nil {
+				authn = &serviceaccount.ExternalTokenAuthenticator{
+					Client:       tc.ExternalServiceClient,
+					Issuers:      tc.Issuer,
+					ImplicitAuds: nil,
+					Validator:    serviceaccount.NewValidator(getter),
+				}
+			} else {
+				authn = serviceaccount.JWTTokenAuthenticator([]string{serviceaccount.LegacyIssuer, "bar"}, tc.Keys, auds, serviceaccount.NewLegacyValidator(tc.Client != nil, getter))
+			}
+			// An invalid, non-JWT token should always fail
+			ctx := authenticator.WithAudiences(context.Background(), auds)
+			if _, ok, err := authn.AuthenticateToken(ctx, "invalid token"); err != nil || ok {
+				t.Errorf("%s: Expected err=nil, ok=false for non-JWT token", k)
+				return
+			}
+
+			resp, ok, err := authn.AuthenticateToken(ctx, tc.Token)
+			if (err != nil) != tc.ExpectedErr {
+				t.Errorf("%s: Expected error=%v, got %v", k, tc.ExpectedErr, err)
+				return
+			}
+
+			if ok != tc.ExpectedOK {
+				t.Errorf("%s: Expected ok=%v, got %v", k, tc.ExpectedOK, ok)
+				return
+			}
+
+			if err != nil || !ok {
+				return
+			}
+
+			if resp.User.GetName() != tc.ExpectedUserName {
+				t.Errorf("%s: Expected username=%v, got %v", k, tc.ExpectedUserName, resp.User.GetName())
+				return
+			}
+			if resp.User.GetUID() != tc.ExpectedUserUID {
+				t.Errorf("%s: Expected userUID=%v, got %v", k, tc.ExpectedUserUID, resp.User.GetUID())
+				return
+			}
+			if !reflect.DeepEqual(resp.User.GetGroups(), tc.ExpectedGroups) {
+				t.Errorf("%s: Expected groups=%v, got %v", k, tc.ExpectedGroups, resp.User.GetGroups())
+				return
+			}
+		})
 	}
 }
 
diff --git a/staging/src/k8s.io/client-go/util/cert/pem.go b/staging/src/k8s.io/client-go/util/cert/pem.go
index c77512315ab..627e9ea9c05 100644
--- a/staging/src/k8s.io/client-go/util/cert/pem.go
+++ b/staging/src/k8s.io/client-go/util/cert/pem.go
@@ -30,6 +30,11 @@ const (
 	CertificateRequestBlockType = "CERTIFICATE REQUEST"
 )
 
+var (
+	// ErrNoCerts is a signal error returned when an x509 Certificate is empty
+	ErrNoCerts = errors.New("data does not contain any valid RSA or ECDSA certificates")
+)
+
 // ParseCertsPEM returns the x509.Certificates contained in the given PEM-encoded byte array
 // Returns an error if a certificate could not be parsed, or if the data does not contain any certificates
 func ParseCertsPEM(pemCerts []byte) ([]*x509.Certificate, error) {
@@ -56,7 +61,7 @@ func ParseCertsPEM(pemCerts []byte) ([]*x509.Certificate, error) {
 	}
 
 	if !ok {
-		return certs, errors.New("data does not contain any valid RSA or ECDSA certificates")
+		return certs, ErrNoCerts
 	}
 	return certs, nil
 }
diff --git a/vendor/gopkg.in/square/go-jose.v2/cryptosigner/cryptosigner.go b/vendor/gopkg.in/square/go-jose.v2/cryptosigner/cryptosigner.go
new file mode 100644
index 00000000000..0ec98768eb1
--- /dev/null
+++ b/vendor/gopkg.in/square/go-jose.v2/cryptosigner/cryptosigner.go
@@ -0,0 +1,138 @@
+/*-
+ * Copyright 2018 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Package cryptosigner implements an OpaqueSigner that wraps a "crypto".Signer
+//
+// https://godoc.org/crypto#Signer
+package cryptosigner
+
+import (
+	"crypto"
+	"crypto/ecdsa"
+	"crypto/rand"
+	"crypto/rsa"
+	"encoding/asn1"
+	"io"
+	"math/big"
+
+	"golang.org/x/crypto/ed25519"
+	"gopkg.in/square/go-jose.v2"
+)
+
+// Opaque creates an OpaqueSigner from a "crypto".Signer
+func Opaque(s crypto.Signer) jose.OpaqueSigner {
+	pk := &jose.JSONWebKey{
+		Key: s.Public(),
+	}
+	return &cryptoSigner{signer: s, rand: rand.Reader, pk: pk}
+}
+
+type cryptoSigner struct {
+	pk     *jose.JSONWebKey
+	signer crypto.Signer
+	rand   io.Reader
+}
+
+func (s *cryptoSigner) Public() *jose.JSONWebKey {
+	return s.pk
+}
+
+func (s *cryptoSigner) Algs() []jose.SignatureAlgorithm {
+	switch s.signer.Public().(type) {
+	case ed25519.PublicKey:
+		return []jose.SignatureAlgorithm{jose.EdDSA}
+	case *ecdsa.PublicKey:
+		// This could be more precise
+		return []jose.SignatureAlgorithm{jose.ES256, jose.ES384, jose.ES512}
+	case *rsa.PublicKey:
+		return []jose.SignatureAlgorithm{jose.RS256, jose.RS384, jose.RS512, jose.PS256, jose.PS384, jose.PS512}
+	default:
+		return nil
+	}
+}
+
+func (s *cryptoSigner) SignPayload(payload []byte, alg jose.SignatureAlgorithm) ([]byte, error) {
+	var hash crypto.Hash
+	switch alg {
+	case jose.EdDSA:
+	case jose.RS256, jose.PS256, jose.ES256:
+		hash = crypto.SHA256
+	case jose.RS384, jose.PS384, jose.ES384:
+		hash = crypto.SHA384
+	case jose.RS512, jose.PS512, jose.ES512:
+		hash = crypto.SHA512
+	default:
+		return nil, jose.ErrUnsupportedAlgorithm
+	}
+
+	var hashed []byte
+	if hash != crypto.Hash(0) {
+		hasher := hash.New()
+		if _, err := hasher.Write(payload); err != nil {
+			return nil, err
+		}
+		hashed = hasher.Sum(nil)
+	}
+
+	var (
+		out []byte
+		err error
+	)
+	switch alg {
+	case jose.EdDSA:
+		out, err = s.signer.Sign(s.rand, payload, crypto.Hash(0))
+	case jose.ES256, jose.ES384, jose.ES512:
+		var byteLen int
+		switch alg {
+		case jose.ES256:
+			byteLen = 32
+		case jose.ES384:
+			byteLen = 48
+		case jose.ES512:
+			byteLen = 66
+		}
+		var b []byte
+		b, err = s.signer.Sign(s.rand, hashed, hash)
+		if err != nil {
+			return nil, err
+		}
+
+		sig := struct {
+			R, S *big.Int
+		}{}
+		if _, err = asn1.Unmarshal(b, &sig); err != nil {
+			return nil, err
+		}
+
+		rBytes := sig.R.Bytes()
+		rBytesPadded := make([]byte, byteLen)
+		copy(rBytesPadded[byteLen-len(rBytes):], rBytes)
+
+		sBytes := sig.S.Bytes()
+		sBytesPadded := make([]byte, byteLen)
+		copy(sBytesPadded[byteLen-len(sBytes):], sBytes)
+
+		out = append(rBytesPadded, sBytesPadded...)
+	case jose.RS256, jose.RS384, jose.RS512:
+		out, err = s.signer.Sign(s.rand, hashed, hash)
+	case jose.PS256, jose.PS384, jose.PS512:
+		out, err = s.signer.Sign(s.rand, hashed, &rsa.PSSOptions{
+			SaltLength: rsa.PSSSaltLengthAuto,
+			Hash:       hash,
+		})
+	}
+	return out, err
+}
diff --git a/vendor/modules.txt b/vendor/modules.txt
index 5a37feffdfc..a16bf886ba6 100644
--- a/vendor/modules.txt
+++ b/vendor/modules.txt
@@ -1236,6 +1236,7 @@ gopkg.in/natefinch/lumberjack.v2
 ## explicit
 gopkg.in/square/go-jose.v2
 gopkg.in/square/go-jose.v2/cipher
+gopkg.in/square/go-jose.v2/cryptosigner
 gopkg.in/square/go-jose.v2/json
 gopkg.in/square/go-jose.v2/jwt
 # gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 => gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7
