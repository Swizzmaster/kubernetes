From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: James Gleixner <jameglei@amazon.com>
Date: Wed, 6 Sep 2023 10:53:38 -0700
Subject: [PATCH] --EKS-PRIVATE-- Adding wait-for-address flag

Adding `wait-for-addresses` kubelet flag.

EKS Fargate requires this flag to address issue https://t.corp.amazon.com/P92672406

Use of external cloud control manager creates a race condition between the node marking itself ready and being able to acquire node addresses to create the CSR.
When kubelet loses the race, the node is ready but users may be unable to exec into pods on the nodes for 30 seconds.
This creates usability issues for EKS Fargate pods as Fargate node lifetimes closely match the pod life times.

The node-ip flag is not useable with EKS Fargate since custom networking considerations mean that the node ip address is not available on a network interface
in the network namespace where the kubelet is running so validations will fail.
---
 cmd/kubelet/app/options/options.go | 5 +++++
 cmd/kubelet/app/server.go          | 3 ++-
 pkg/kubelet/kubelet.go             | 5 +++++
 pkg/kubelet/kubelet_node_status.go | 5 +++++
 pkg/kubelet/kubelet_test.go        | 1 +
 5 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/cmd/kubelet/app/options/options.go b/cmd/kubelet/app/options/options.go
index aafd37a5283..bd0c7531092 100644
--- a/cmd/kubelet/app/options/options.go
+++ b/cmd/kubelet/app/options/options.go
@@ -62,6 +62,9 @@ type KubeletFlags struct {
 	// If set, kubelet will use this IP address for the node.
 	NodeIP string
 
+	// WaitForAddresses will direct the kubelet to wait for the control plane to populate ip addresses before marking itself ready.
+	WaitForAddresses bool
+
 	// Container-runtime-specific options.
 	config.ContainerRuntimeOptions
 
@@ -297,6 +300,8 @@ func (f *KubeletFlags) AddFlags(mainfs *pflag.FlagSet) {
 
 	fs.StringVar(&f.NodeIP, "node-ip", f.NodeIP, "IP address (or comma-separated dual-stack IP addresses) of the node. If unset, kubelet will use the node's default IPv4 address, if any, or its default IPv6 address if it has no IPv4 addresses. You can pass '::' to make it prefer the default IPv6 address rather than the default IPv4 address.")
 
+	fs.BoolVar(&f.WaitForAddresses, "wait-for-addresses", f.WaitForAddresses, "If true, the kubelet will wait to ingest ip addresses from the control plane before marking itself ready")
+
 	fs.StringVar(&f.CertDirectory, "cert-dir", f.CertDirectory, "The directory where the TLS certs are located. "+
 		"If --tls-cert-file and --tls-private-key-file are provided, this flag will be ignored.")
 
diff --git a/cmd/kubelet/app/server.go b/cmd/kubelet/app/server.go
index 76e8cdf7b99..df773a920e8 100644
--- a/cmd/kubelet/app/server.go
+++ b/cmd/kubelet/app/server.go
@@ -1307,7 +1307,8 @@ func createAndInitKubelet(kubeServer *options.KubeletServer,
 		kubeServer.KeepTerminatedPodVolumes,
 		kubeServer.NodeLabels,
 		kubeServer.NodeStatusMaxImages,
-		kubeServer.KubeletFlags.SeccompDefault || kubeServer.KubeletConfiguration.SeccompDefault)
+		kubeServer.KubeletFlags.SeccompDefault || kubeServer.KubeletConfiguration.SeccompDefault,
+		kubeServer.WaitForAddresses)
 	if err != nil {
 		return nil, err
 	}
diff --git a/pkg/kubelet/kubelet.go b/pkg/kubelet/kubelet.go
index 0e09e50c046..fb04022f6c2 100644
--- a/pkg/kubelet/kubelet.go
+++ b/pkg/kubelet/kubelet.go
@@ -363,6 +363,7 @@ func NewMainKubelet(kubeCfg *kubeletconfiginternal.KubeletConfiguration,
 	nodeLabels map[string]string,
 	nodeStatusMaxImages int32,
 	seccompDefault bool,
+	waitForAddresses bool,
 ) (*Kubelet, error) {
 	ctx := context.Background()
 	logger := klog.TODO()
@@ -555,6 +556,7 @@ func NewMainKubelet(kubeCfg *kubeletconfiginternal.KubeletConfiguration,
 		containerManager:               kubeDeps.ContainerManager,
 		nodeIPs:                        nodeIPs,
 		nodeIPValidator:                validateNodeIP,
+		waitForAddresses:               waitForAddresses,
 		clock:                          clock.RealClock{},
 		enableControllerAttachDetach:   kubeCfg.EnableControllerAttachDetach,
 		makeIPTablesUtilChains:         kubeCfg.MakeIPTablesUtilChains,
@@ -1251,6 +1253,9 @@ type Kubelet struct {
 	// use this function to validate the kubelet nodeIP
 	nodeIPValidator func(net.IP) error
 
+	// If true, wait for control plane to provide addresses before marking node ready
+	waitForAddresses bool
+
 	// If non-nil, this is a unique identifier for the node in an external database, eg. cloudprovider
 	providerID string
 
diff --git a/pkg/kubelet/kubelet_node_status.go b/pkg/kubelet/kubelet_node_status.go
index 7723abc64b2..6345a10523a 100644
--- a/pkg/kubelet/kubelet_node_status.go
+++ b/pkg/kubelet/kubelet_node_status.go
@@ -469,6 +469,11 @@ func (kl *Kubelet) fastNodeStatusUpdate(ctx context.Context, timeout bool) (comp
 		return false
 	}
 
+	if kl.waitForAddresses && (originalNode.Status.Addresses == nil || len(originalNode.Status.Addresses) == 0) {
+		klog.ErrorS(nil, "Node does not have addresses", "originalNode", originalNode)
+		return false
+	}
+
 	if originalNodeReady.Status == v1.ConditionTrue {
 		return true
 	}
diff --git a/pkg/kubelet/kubelet_test.go b/pkg/kubelet/kubelet_test.go
index 09de07fa501..dcd086a5415 100644
--- a/pkg/kubelet/kubelet_test.go
+++ b/pkg/kubelet/kubelet_test.go
@@ -3190,6 +3190,7 @@ func TestNewMainKubeletStandAlone(t *testing.T) {
 		map[string]string{},
 		1024,
 		false,
+        false,
 	)
 	assert.NoError(t, err, "NewMainKubelet should succeed")
 	assert.NotNil(t, testMainKubelet, "testMainKubelet should not be nil")
